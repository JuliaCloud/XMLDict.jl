<?xml version="1.0" encoding="utf-8"?>
<spec w3c-doctype="rec" lang="en">
  <header>
    <title>Extensible Markup Language (XML)</title>
    <version>1.0 (Fifth Edition)</version>
    <w3c-designation>REC-xml-20081126</w3c-designation>
    <w3c-doctype>W3C Recommendation</w3c-doctype>
    <pubdate>
      <day>26</day>
      <month>November</month>
      <year>2008</year>
    </pubdate>
    <publoc>
      <loc href="http://www.w3.org/TR/2008/REC-xml-20081126/">
      http://www.w3.org/TR/2008/REC-xml-20081126/</loc>
    </publoc>
    <altlocs>
      <loc href="REC-xml-20081126.xml">XML</loc>
      <loc href="REC-xml-20081126-review.html">XHTML with
      color-coded revision indicators</loc>
    </altlocs>
    <latestloc>
      <loc href="http://www.w3.org/TR/xml/">
      http://www.w3.org/TR/xml/</loc>
    </latestloc>
    <prevlocs>
      <loc href="http://www.w3.org/TR/2008/PER-xml-20080205/">
      http://www.w3.org/TR/2008/PER-xml-20080205/</loc>
      <loc href="http://www.w3.org/TR/2006/REC-xml-20060816/">
      http://www.w3.org/TR/2006/REC-xml-20060816/</loc>
    </prevlocs>
    <authlist>
      <author role="1e">
        <name>Tim Bray</name>
        <affiliation>Textuality and Netscape</affiliation>
        <email href="mailto:tbray@textuality.com">
        tbray@textuality.com</email>
      </author>
      <author role="1e">
        <name>Jean Paoli</name>
        <affiliation>Microsoft</affiliation>
        <email href="mailto:jeanpa@microsoft.com">
        jeanpa@microsoft.com</email>
      </author>
      <author role="1e">
        <name>C. M. Sperberg-McQueen</name>
        <affiliation>W3C</affiliation>
        <email href="mailto:cmsmcq@w3.org">cmsmcq@w3.org</email>
      </author>
      <author>
        <name>Eve Maler</name>
        <affiliation>Sun Microsystems, Inc.</affiliation>
        <email href="mailto:elm@east.sun.com">
        eve.maler@east.sun.com</email>
      </author>
      <author>
        <name>Fran&#195;&#167;ois Yergeau</name>
      </author>
    </authlist>
    <errataloc href="http://www.w3.org/XML/xml-V10-5e-errata" />
    <preverrataloc href="http://www.w3.org/XML/xml-V10-4e-errata" />
    <translationloc href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xml" />
    <abstract>
      <p>The Extensible Markup Language (XML) is a subset of SGML
      that is completely described in this document. Its goal is to
      enable generic SGML to be served, received, and processed on
      the Web in the way that is now possible with HTML. XML has
      been designed for ease of implementation and for
      interoperability with both SGML and HTML.</p>
    </abstract>
    <status>
      <p>
        <emph>This section describes the status of this document at
        the time of its publication. Other documents may supersede
        this document. A list of current W3C publications and the
        latest revision of this technical report can be found in
        the 
        <loc href="http://www.w3.org/TR/">W3C technical reports
        index</loc>at http://www.w3.org/TR/.</emph>
      </p>
      <p>This document specifies a syntax created by subsetting an
      existing, widely used international text processing standard
      (Standard Generalized Markup Language, ISO 8879:1986(E) as
      amended and corrected) for use on the World Wide Web. It is a
      product of the 
      <loc href="http://www.w3.org/XML/Core/">XML Core Working
      Group</loc>as part of the 
      <loc href="http://www.w3.org/XML/Activity">XML
      Activity</loc>. The English version of this specification is
      the only normative version. However, for translations of this
      document, see 
      <loc href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xml">
      http://www.w3.org/2003/03/Translations/byTechnology?technology=xml</loc>.</p>
      <p>This document is a 
      <loc href="http://www.w3.org/2005/10/Process-20051014/tr.html#q74">
      W3C Recommendation</loc>. This fifth edition is 
      <emph>not</emph>a new version of XML. As a convenience to
      readers, it incorporates the changes dictated by the
      accumulated errata (available at 
      <loc href="http://www.w3.org/XML/xml-V10-4e-errata">
      http://www.w3.org/XML/xml-V10-4e-errata</loc>) to the 
      <loc href="http://www.w3.org/TR/2006/REC-xml-20060816/">
      Fourth Edition of XML 1.0, dated 16 August 2006</loc>. In
      particular, erratum 
      <loc href="http://www.w3.org/XML/xml-V10-4e-errata#E09">
      [E09]</loc>relaxes the restrictions on element and attribute
      names, thereby providing in XML 1.0 the major end user
      benefit currently achievable only by using XML 1.1. As a
      consequence, many possible documents which were not
      well-formed according to previous editions of this
      specification are now well-formed, and previously invalid
      documents using the newly-allowed name characters in, for
      example, ID attributes, are now valid.</p>
      <p>This edition supersedes the previous 
      <loc href="http://www.w3.org/TR/2006/REC-xml-20060816/">W3C
      Recommendation of 16 August 2006</loc>.</p>
      <p>Please report errors in this document to the public 
      <loc href="mailto:xml-editor@w3.org">
      xml-editor@w3.org</loc>mail list; public 
      <loc href="http://lists.w3.org/Archives/Public/xml-editor/">
      archives</loc>are available. For the convenience of readers,
      an 
      <loc href="REC-xml-20081126-review.html">XHTML version with
      color-coded revision indicators</loc>is also provided; this
      version highlights each change due to an erratum published in
      the 
      <loc href="http://www.w3.org/XML/xml-V10-4e-errata">errata
      list</loc>for the previous edition, together with a link to
      the particular erratum in that list. Most of the errata in
      the list provide a rationale for the change. The errata list
      for this fifth edition is available at 
      <loc href="http://www.w3.org/XML/xml-V10-5e-errata">
      http://www.w3.org/XML/xml-V10-5e-errata</loc>.</p>
      <p>An implementation report is available at 
      <loc href="http://www.w3.org/XML/2008/01/xml10-5e-implementation.html">
      http://www.w3.org/XML/2008/01/xml10-5e-implementation.html</loc>.
      A 
      <loc href="http://www.w3.org/XML/Test/">Test Suite</loc>is
      maintained to help assessing conformance to this
      specification.</p>
      <p>This document has been reviewed by W3C Members, by
      software developers, and by other W3C groups and interested
      parties, and is endorsed by the Director as a W3C
      Recommendation. It is a stable document and may be used as
      reference material or cited from another document. W3C's role
      in making the Recommendation is to draw attention to the
      specification and to promote its widespread deployment. This
      enhances the functionality and interoperability of the
      Web.</p>
      <p>W3C maintains a 
      <loc role="disclosure"
      href="http://www.w3.org/2002/08/xmlcore-IPR-statements">
      public list of any patent disclosures</loc>made in connection
      with the deliverables of the group; that page also includes
      instructions for disclosing a patent. An individual who has
      actual knowledge of a patent which the individual believes
      contains 
      <loc href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">
      Essential Claim(s)</loc>must disclose the information in
      accordance with 
      <loc href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">
      section 6 of the W3C Patent Policy</loc>.</p>
    </status>
    <pubstmt>
      <p>Chicago, Vancouver, Mountain View, Edinburgh, et al.:
      World-Wide Web Consortium, XML Working Group, 1996, 1997,
      2000, 2006, 2008.</p>
    </pubstmt>
    <sourcedesc>
      <p>Created in electronic form.</p>
    </sourcedesc>
    <langusage>
      <language id="EN">English</language>
      <language id="ebnf">Extended Backus-Naur Form (formal
      grammar)</language>
    </langusage>
    <revisiondesc>
      <p role="cvsid">$Id: REC-xml-20081126.xml,v 1.3 2013-02-07
      15:01:59 denis Exp $</p>
    </revisiondesc>
  </header>
  <body>
    <div1 id="sec-intro">
      <head>Introduction</head>
      <p>Extensible Markup Language, abbreviated XML, describes a
      class of data objects called 
      <termref def="dt-xml-doc">XML documents</termref>and
      partially describes the behavior of computer programs which
      process them. XML is an application profile or restricted
      form of SGML, the Standard Generalized Markup Language 
      <bibref ref="ISO8879" />. By construction, XML documents are
      conforming SGML documents.</p>
      <p>XML documents are made up of storage units called 
      <termref def="dt-entity">entities</termref>, which contain
      either parsed or unparsed data. Parsed data is made up of 
      <termref def="dt-character">characters</termref>, some of
      which form 
      <termref def="dt-chardata">character data</termref>, and some
      of which form 
      <termref def="dt-markup">markup</termref>. Markup encodes a
      description of the document's storage layout and logical
      structure. XML provides a mechanism to impose constraints on
      the storage layout and logical structure.</p>
      <p>
      <termdef id="dt-xml-proc" term="XML Processor">A software
      module called an 
      <term>XML processor</term>is used to read XML documents and
      provide access to their content and structure.</termdef>
      <termdef id="dt-app" term="Application">It is assumed that an
      XML processor is doing its work on behalf of another module,
      called the 
      <term>application</term>.</termdef>This specification
      describes the required behavior of an XML processor in terms
      of how it must read XML data and the information it must
      provide to the application.</p>
      <div2 id="sec-origin-goals">
        <head>Origin and Goals</head>
        <p>XML was developed by an XML Working Group (originally
        known as the SGML Editorial Review Board) formed under the
        auspices of the World Wide Web Consortium (W3C) in 1996. It
        was chaired by Jon Bosak of Sun Microsystems with the
        active participation of an XML Special Interest Group
        (previously known as the SGML Working Group) also organized
        by the W3C. The membership of the XML Working Group is
        given in an appendix. Dan Connolly served as the Working
        Group's contact with the W3C.</p>
        <p>The design goals for XML are:</p>
        <olist>
          <item>
            <p>XML shall be straightforwardly usable over the
            Internet.</p>
          </item>
          <item>
            <p>XML shall support a wide variety of
            applications.</p>
          </item>
          <item>
            <p>XML shall be compatible with SGML.</p>
          </item>
          <item>
            <p>It shall be easy to write programs which process XML
            documents.</p>
          </item>
          <item>
            <p>The number of optional features in XML is to be kept
            to the absolute minimum, ideally zero.</p>
          </item>
          <item>
            <p>XML documents should be human-legible and reasonably
            clear.</p>
          </item>
          <item>
            <p>The XML design should be prepared quickly.</p>
          </item>
          <item>
            <p>The design of XML shall be formal and concise.</p>
          </item>
          <item>
            <p>XML documents shall be easy to create.</p>
          </item>
          <item>
            <p>Terseness in XML markup is of minimal
            importance.</p>
          </item>
        </olist>
        <p>This specification, together with associated standards
        (Unicode 
        <bibref ref="Unicode" />and ISO/IEC 10646 
        <bibref ref="ISO10646" />for characters, Internet 
        <phrase diff="del">RFC 3066</phrase>
        <phrase diff="add">
        <loc role="erratumref" href="E01" />BCP 47</phrase>
        <bibref ref="RFC1766" />
        <phrase diff="add">
        <loc role="erratumref" href="E01" />and the Language Subtag
        Registry 
        <bibref ref="IANA-LANGCODES" /></phrase>for language
        identification tags
        <phrase diff="del">
        <loc role="erratumref" href="E01" />, ISO 639 
        <bibref ref="ISO639" />for language name codes, and ISO
        3166 
        <bibref ref="ISO3166" />for country name codes</phrase>),
        provides all the information necessary to understand XML
        Version 1.0 and construct computer programs to process
        it.</p>
        <p>This version of the XML specification may be distributed
        freely, as long as all text and legal notices remain
        intact.</p>
      </div2>
      <div2 id="sec-terminology">
        <head>Terminology</head>
        <p>The terminology used to describe XML documents is
        defined in the body of this specification. The key words 
        <rfc2119>MUST</rfc2119>, 
        <rfc2119>MUST NOT</rfc2119>, 
        <rfc2119>REQUIRED</rfc2119>, 
        <rfc2119>SHALL</rfc2119>, 
        <rfc2119>SHALL NOT</rfc2119>, 
        <rfc2119>SHOULD</rfc2119>, 
        <rfc2119>SHOULD NOT</rfc2119>, 
        <rfc2119>RECOMMENDED</rfc2119>, 
        <rfc2119>MAY</rfc2119>, and 
        <rfc2119>OPTIONAL</rfc2119>, when 
        <rfc2119>EMPHASIZED</rfc2119>, are to be interpreted as
        described in 
        <bibref ref="rfc2119" />. In addition, the terms defined in
        the following list are used in building those definitions
        and in describing the actions of an XML processor:
        <glist>
          <gitem>
            <label>error</label>
            <def>
              <p>
                <termdef id="dt-error" term="Error">A violation of
                the rules of this specification; results are
                undefined. Unless otherwise specified, failure to
                observe a prescription of this specification
                indicated by one of the keywords 
                <rfc2119>MUST</rfc2119>, 
                <rfc2119>REQUIRED</rfc2119>, 
                <rfc2119>MUST NOT</rfc2119>, 
                <rfc2119>SHALL</rfc2119>and 
                <rfc2119>SHALL NOT</rfc2119>is an error. Conforming
                software 
                <rfc2119>MAY</rfc2119>detect and report an error
                and 
                <rfc2119>MAY</rfc2119>recover from it.</termdef>
              </p>
            </def>
          </gitem>
          <gitem>
            <label>fatal error</label>
            <def>
              <p>
                <termdef id="dt-fatal" term="Fatal Error">An error
                which a conforming 
                <termref def="dt-xml-proc">XML processor</termref>
                <rfc2119>MUST</rfc2119>detect and report to the
                application. After encountering a fatal error, the
                processor 
                <rfc2119>MAY</rfc2119>continue processing the data
                to search for further errors and 
                <rfc2119>MAY</rfc2119>report such errors to the
                application. In order to support correction of
                errors, the processor 
                <rfc2119>MAY</rfc2119>make unprocessed data from
                the document (with intermingled character data and
                markup) available to the application. Once a fatal
                error is detected, however, the processor 
                <rfc2119>MUST NOT</rfc2119>continue normal
                processing (i.e., it 
                <rfc2119>MUST NOT</rfc2119>continue to pass
                character data and information about the document's
                logical structure to the application in the normal
                way).</termdef>
              </p>
            </def>
          </gitem>
          <gitem>
            <label>at user option</label>
            <def>
              <p>
                <termdef id="dt-atuseroption"
                term="At user option">Conforming software 
                <rfc2119>MAY</rfc2119>or 
                <rfc2119>MUST</rfc2119>(depending on the modal verb
                in the sentence) behave as described; if it does,
                it 
                <rfc2119>MUST</rfc2119>provide users a means to
                enable or disable the behavior described.</termdef>
              </p>
            </def>
          </gitem>
          <gitem>
            <label>validity constraint</label>
            <def>
              <p>
                <termdef id="dt-vc" term="Validity constraint">A
                rule which applies to all 
                <termref def="dt-valid">valid</termref>XML
                documents. Violations of validity constraints are
                errors; they 
                <rfc2119>MUST</rfc2119>, at user option, be
                reported by 
                <termref def="dt-validating">validating XML
                processors</termref>.</termdef>
              </p>
            </def>
          </gitem>
          <gitem>
            <label>well-formedness constraint</label>
            <def>
              <p>
                <termdef id="dt-wfc"
                term="Well-formedness constraint">A rule which
                applies to all 
                <termref def="dt-wellformed">
                well-formed</termref>XML documents. Violations of
                well-formedness constraints are 
                <termref def="dt-fatal">fatal
                errors</termref>.</termdef>
              </p>
            </def>
          </gitem>
          <gitem>
            <label>match</label>
            <def>
              <p>
                <termdef id="dt-match" term="match">(Of strings or
                names:) Two strings or names being compared are
                identical. Characters with multiple possible
                representations in ISO/IEC 10646 (e.g. characters
                with both precomposed and base+diacritic forms)
                match only if they have the same representation in
                both strings. No case folding is performed. (Of
                strings and rules in the grammar:) A string matches
                a grammatical production if it belongs to the
                language generated by that production. (Of content
                and content models:) An element matches its
                declaration when it conforms in the fashion
                described in the constraint 
                <specref ref="elementvalid" />.</termdef>
              </p>
            </def>
          </gitem>
          <gitem>
            <label>for compatibility</label>
            <def>
              <p>
                <termdef id="dt-compat" term="For Compatibility">
                Marks a sentence describing a feature of XML
                included solely to ensure that XML remains
                compatible with SGML.</termdef>
              </p>
            </def>
          </gitem>
          <gitem>
            <label>for interoperability</label>
            <def>
              <p>
                <termdef id="dt-interop"
                term="For interoperability">Marks a sentence
                describing a non-binding recommendation included to
                increase the chances that XML documents can be
                processed by the existing installed base of SGML
                processors which predate the WebSGML Adaptations
                Annex to ISO 8879.</termdef>
              </p>
            </def>
          </gitem>
        </glist></p>
      </div2>
    </div1>
    <div1 id="sec-documents">
      <head>Documents</head>
      <p>
        <termdef id="dt-xml-doc" term="XML Document">A data object
        is an 
        <term>XML document</term>if it is 
        <termref def="dt-wellformed">well-formed</termref>, as
        defined in this specification. In addition, the XML
        document is 
        <termref def="dt-valid">valid</termref>if it meets certain
        further constraints.</termdef>
      </p>
      <p>Each XML document has both a logical and a physical
      structure. Physically, the document is composed of units
      called 
      <termref def="dt-entity">entities</termref>. An entity may 
      <termref def="dt-entref">refer</termref>to other entities to
      cause their inclusion in the document. A document begins in a
      
      <quote>root</quote>or 
      <termref def="dt-docent">document entity</termref>.
      Logically, the document is composed of declarations,
      elements, comments, character references, and processing
      instructions, all of which are indicated in the document by
      explicit markup. The logical and physical structures 
      <rfc2119>MUST</rfc2119>nest properly, as described in 
      <specref ref="wf-entities" />.</p>
      <div2 id="sec-well-formed">
        <head>Well-Formed XML Documents</head>
        <p>
          <termdef id="dt-wellformed" term="Well-Formed">A textual
          object is a 
          <term>well-formed</term>XML document if:</termdef>
        </p>
        <olist>
          <item>
            <p>Taken as a whole, it matches the production labeled 
            <nt def="NT-document">document</nt>.</p>
          </item>
          <item>
            <p>It meets all the well-formedness constraints given
            in this specification.</p>
          </item>
          <item>
            <p>Each of the 
            <termref def="dt-parsedent">parsed
            entities</termref>which is referenced directly or
            indirectly within the document is 
            <termref def="dt-wellformed">well-formed</termref>.</p>
          </item>
        </olist>
        <scrap id="document" lang="ebnf">
          <head>Document</head>
          <prod id="NT-document" num="1">
            <lhs>document</lhs>
            <rhs>
            <nt def="NT-prolog">prolog</nt>
            <nt def="NT-element">element</nt>
            <nt def="NT-Misc">Misc</nt>*</rhs>
          </prod>
        </scrap>
        <p>Matching the 
        <nt def="NT-document">document</nt>production implies
        that:</p>
        <olist>
          <item>
            <p>It contains one or more 
            <termref def="dt-element">elements</termref>.</p>
          </item>
          <item>
            <p>
            <termdef id="dt-root" term="Root Element">There is
            exactly one element, called the 
            <term>root</term>, or document element, no part of
            which appears in the 
            <termref def="dt-content">content</termref>of any other
            element.</termdef>For all other elements, if the 
            <termref def="dt-stag">start-tag</termref>is in the
            content of another element, the 
            <termref def="dt-etag">end-tag</termref>is in the
            content of the same element. More simply stated, the
            elements, delimited by start- and end-tags, nest
            properly within each other.</p>
          </item>
        </olist>
        <p>
          <termdef id="dt-parentchild" term="Parent/Child">As a
          consequence of this, for each non-root element 
          <el>C</el>in the document, there is one other element 
          <el>P</el>in the document such that 
          <el>C</el>is in the content of 
          <el>P</el>, but is not in the content of any other
          element that is in the content of 
          <el>P</el>. 
          <el>P</el>is referred to as the 
          <term>parent</term>of 
          <el>C</el>, and 
          <el>C</el>as a 
          <term>child</term>of 
          <el>P</el>.</termdef>
        </p>
      </div2>
      <div2 id="charsets">
        <head>Characters</head>
        <p>
          <termdef id="dt-text" term="Text">A parsed entity
          contains 
          <term>text</term>, a sequence of 
          <termref def="dt-character">characters</termref>, which
          may represent markup or character data.</termdef>
          <termdef id="dt-character" term="Character">A 
          <term>character</term>is an atomic unit of text as
          specified by ISO/IEC 10646:2000 
          <bibref ref="ISO10646" />. Legal characters are tab,
          carriage return, line feed, and the legal characters of
          Unicode and ISO/IEC 10646. The versions of these
          standards cited in 
          <specref ref="sec-existing-stds" />were current at the
          time this document was prepared. New characters may be
          added to these standards by amendments or new editions.
          Consequently, XML processors 
          <rfc2119>MUST</rfc2119>accept any character in the range
          specified for 
          <nt def="NT-Char">Char</nt>.</termdef>
        </p>
        <scrap id="char32" lang="ebnf">
          <head>Character Range</head>
          <prodgroup pcw2="4" pcw4="17.5" pcw5="11">
            <prod id="NT-Char" num="2">
              <lhs>Char</lhs>
              <rhs>#x9 | #xA | #xD | [#x20-#xD7FF] |
              [#xE000-#xFFFD] | [#x10000-#x10FFFF]</rhs>
              <com>any Unicode character, excluding the surrogate
              blocks, FFFE, and FFFF.</com>
            </prod>
          </prodgroup>
        </scrap>
        <p>The mechanism for encoding character code points into
        bit patterns may vary from entity to entity. All XML
        processors 
        <rfc2119>MUST</rfc2119>accept the UTF-8 and UTF-16
        encodings of Unicode
        <phrase diff="del">
        <loc role="erratumref" href="E11" />3.1</phrase>
        <phrase diff="chg">
          <loc role="erratumref" href="E11" />
          <bibref ref="Unicode" />
        </phrase>; the mechanisms for signaling which of the two is
        in use, or for bringing other encodings into play, are
        discussed later, in 
        <specref ref="charencoding" />.</p>
        <note>
          <p>Document authors are encouraged to avoid 
          <quote>compatibility characters</quote>, as defined in
          section 
          <phrase diff="chg">
          <loc role="erratumref" href="E11" />2.3</phrase>of 
          <bibref ref="Unicode" />
          <phrase diff="del">
          <loc role="erratumref" href="E11" />(see also D21 in
          section 3.6 of 
          <bibref ref="Unicode3" />)</phrase>. The characters
          defined in the following ranges are also discouraged.
          They are either control characters or permanently
          undefined Unicode characters:</p>
          <eg>[#x7F-#x84], [#x86-#x9F], [#xFDD0-#xFD
          <phrase diff="chg">
          <loc role="erratumref" href="E02" />E</phrase>F],
          [#x1FFFE-#x1FFFF], [#x2FFFE-#x2FFFF], [#x3FFFE-#x3FFFF],
          [#x4FFFE-#x4FFFF], [#x5FFFE-#x5FFFF], [#x6FFFE-#x6FFFF],
          [#x7FFFE-#x7FFFF], [#x8FFFE-#x8FFFF], [#x9FFFE-#x9FFFF],
          [#xAFFFE-#xAFFFF], [#xBFFFE-#xBFFFF], [#xCFFFE-#xCFFFF],
          [#xDFFFE-#xDFFFF], [#xEFFFE-#xEFFFF], [#xFFFFE-#xFFFFF],
          [#x10FFFE-#x10FFFF].</eg>
        </note>
      </div2>
      <div2 id="sec-common-syn">
        <head>Common Syntactic Constructs</head>
        <p>This section defines some symbols used widely in the
        grammar.</p>
        <p>
        <nt def="NT-S">S</nt>(white space) consists of one or more
        space (#x20) characters, carriage returns, line feeds, or
        tabs.</p>
        <scrap id="white" lang="ebnf">
          <head>White Space</head>
          <prodgroup pcw2="4" pcw4="17.5" pcw5="11">
            <prod id="NT-S" num="3">
              <lhs>S</lhs>
              <rhs>(#x20 | #x9 | #xD | #xA)+</rhs>
            </prod>
          </prodgroup>
        </scrap>
        <note>
          <p>The presence of #xD in the above production is
          maintained purely for backward compatibility with the 
          <loc href="http://www.w3.org/TR/1998/REC-xml-19980210">
          First Edition</loc>. As explained in 
          <specref ref="sec-line-ends" />, all #xD characters
          literally present in an XML document are either removed
          or replaced by #xA characters before any other processing
          is done. The only way to get a #xD character to match
          this production is to use a character reference in an
          entity value literal.</p>
        </note>
        <p diff="del">
        <loc role="erratumref" href="E09" />Characters are
        classified for convenience as letters, digits, or other
        characters. A letter consists of an alphabetic or syllabic
        base character or an ideographic character. Full
        definitions of the specific characters in each class are
        given in 
        <specref ref="CharClasses" />.</p>
        <p>An 
        <nt def="NT-Nmtoken">Nmtoken</nt>(name token) is any
        mixture of name characters.</p>
        <p diff="del">
          <loc role="erratumref" href="E09" />
          <termdef id="dt-name-x" term="Name">A 
          <term>Name</term>is a token beginning with a letter or
          one of a few punctuation characters, and continuing with
          letters, digits, hyphens, underscores, colons, or full
          stops, together known as name characters.</termdef>
        </p>
        <p diff="add">
        <loc role="erratumref" href="E09" />
        <termdef id="dt-name" term="Name">A 
        <nt def="NT-Name">Name</nt>is an 
        <nt def="NT-Nmtoken">Nmtoken</nt>with a restricted set of
        initial characters.</termdef>Disallowed initial characters
        for 
        <nt def="NT-Name">Names</nt>include digits, diacritics, the
        full stop and the hyphen.</p>
        <p>Names beginning with the string 
        <quote>
          <code>xml</code>
        </quote>, or with any string which would match 
        <code>(('X'|'x') ('M'|'m') ('L'|'l'))</code>, are reserved
        for standardization in this or future versions of this
        specification.</p>
        <note>
          <p>The Namespaces in XML Recommendation 
          <bibref ref="xml-names" />assigns a meaning to names
          containing colon characters. Therefore, authors should
          not use the colon in XML names except for namespace
          purposes, but XML processors must accept the colon as a
          name character.</p>
        </note>
        <p diff="add">
        <loc role="erratumref" href="E09" />The first character of
        a 
        <nt def="NT-Name">Name</nt>
        <rfc2119>MUST</rfc2119>be a 
        <nt def="NT-NameStartChar">NameStartChar</nt>, and any
        other characters 
        <rfc2119>MUST</rfc2119>be 
        <nt def="NT-NameChar">NameChars</nt>; this mechanism is
        used to prevent names from beginning with European (ASCII)
        digits or with basic combining characters. Almost all
        characters are permitted in names, except those which
        either are or reasonably could be used as delimiters. The
        intention is to be inclusive rather than exclusive, so that
        writing systems not yet encoded in Unicode can be used in
        XML names. See 
        <specref ref="sec-suggested-names" />for suggestions on the
        creation of names.</p>
        <p diff="add">
        <loc role="erratumref" href="E09" />Document authors are
        encouraged to use names which are meaningful words or
        combinations of words in natural languages, and to avoid
        symbolic or white space characters in names. Note that
        COLON, HYPHEN-MINUS, FULL STOP (period), LOW LINE
        (underscore), and MIDDLE DOT are explicitly permitted.</p>
        <p diff="add">
        <loc role="erratumref" href="E09" />The ASCII symbols and
        punctuation marks, along with a fairly large group of
        Unicode symbol characters, are excluded from names because
        they are more useful as delimiters in contexts where XML
        names are used outside XML documents; providing this group
        gives those contexts hard guarantees about what 
        <emph>cannot</emph>be part of an XML name. The character
        #x037E, GREEK QUESTION MARK, is excluded because when
        normalized it becomes a semicolon, which could change the
        meaning of entity references.</p>
        <scrap lang="ebnf">
          <head>Names and Tokens</head>
          <prod id="NT-NameStartChar" num="4">
            <lhs diff="chg">NameStartChar</lhs>
            <rhs diff="chg">":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6]
            | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] |
            [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] |
            [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] |
            [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]</rhs>
            <com diff="chg">
              <loc role="erratumref" href="E09" />
            </com>
          </prod>
          <prod id="NT-NameChar" num="4a" diff="add">
            <lhs>NameChar</lhs>
            <rhs>
            <nt def="NT-NameStartChar">NameStartChar</nt>| "-" |
            "." | [0-9] | #xB7 | [#x0300-#x036F] |
            [#x203F-#x2040]</rhs>
            <com diff="add">
              <loc role="erratumref" href="E09" />
            </com>
          </prod>
          <prod id="NT-Name" num="5">
            <lhs>Name</lhs>
            <rhs diff="chg">
            <nt def="NT-NameStartChar">NameStartChar</nt>(
            <nt def="NT-NameChar">NameChar</nt>)*</rhs>
            <com diff="chg">
              <loc role="erratumref" href="E09" />
            </com>
          </prod>
          <prod id="NT-Names" num="6">
            <lhs>Names</lhs>
            <rhs>
            <nt def="NT-Name">Name</nt>(#x20 
            <nt def="NT-Name">Name</nt>)*</rhs>
          </prod>
          <prod id="NT-Nmtoken" num="7">
            <lhs>Nmtoken</lhs>
            <rhs>(
            <nt def="NT-NameChar">NameChar</nt>)+</rhs>
          </prod>
          <prod id="NT-Nmtokens" num="8">
            <lhs>Nmtokens</lhs>
            <rhs>
            <nt def="NT-Nmtoken">Nmtoken</nt>(#x20 
            <nt def="NT-Nmtoken">Nmtoken</nt>)*</rhs>
          </prod>
        </scrap>
        <note>
          <p>The 
          <nt def="NT-Names">Names</nt>and 
          <nt def="NT-Nmtokens">Nmtokens</nt>productions are used
          to define the validity of tokenized attribute values
          after normalization (see 
          <specref ref="sec-attribute-types" />).</p>
        </note>
        <p>Literal data is any quoted string not containing the
        quotation mark used as a delimiter for that string.
        Literals are used for specifying the content of internal
        entities (
        <nt def="NT-EntityValue">EntityValue</nt>), the values of
        attributes (
        <nt def="NT-AttValue">AttValue</nt>), and external
        identifiers (
        <nt def="NT-SystemLiteral">SystemLiteral</nt>). Note that a
        
        <nt def="NT-SystemLiteral">SystemLiteral</nt>can be parsed
        without scanning for markup.</p>
        <scrap lang="ebnf">
          <head>Literals</head>
          <prod id="NT-EntityValue" num="9">
            <lhs>EntityValue</lhs>
            <rhs>'"' ([^%&amp;"] | 
            <nt def="NT-PEReference">PEReference</nt>| 
            <nt def="NT-Reference">Reference</nt>)* '"'</rhs>
            <rhs>|&#194;&#160; "'" ([^%&amp;'] | 
            <nt def="NT-PEReference">PEReference</nt>| 
            <nt def="NT-Reference">Reference</nt>)* "'"</rhs>
          </prod>
          <prod id="NT-AttValue" num="10">
            <lhs>AttValue</lhs>
            <rhs>'"' ([^&lt;&amp;"] | 
            <nt def="NT-Reference">Reference</nt>)* '"'</rhs>
            <rhs>|&#194;&#160; "'" ([^&lt;&amp;'] | 
            <nt def="NT-Reference">Reference</nt>)* "'"</rhs>
          </prod>
          <prod id="NT-SystemLiteral" num="11">
            <lhs>SystemLiteral</lhs>
            <rhs>('"' [^"]* '"') |&#194;&#160;("'" [^']* "'")</rhs>
          </prod>
          <prod id="NT-PubidLiteral" num="12">
            <lhs>PubidLiteral</lhs>
            <rhs>'"' 
            <nt def="NT-PubidChar">PubidChar</nt>* '"' | "'" (
            <nt def="NT-PubidChar">PubidChar</nt>- "'")* "'"</rhs>
          </prod>
          <prod id="NT-PubidChar" num="13">
            <lhs>PubidChar</lhs>
            <rhs>#x20 | #xD | #xA |&#194;&#160;[a-zA-Z0-9]
            |&#194;&#160;[-'()+,./:=?;!*#@$_%]</rhs>
          </prod>
        </scrap>
        <note>
          <p>Although the 
          <nt def="NT-EntityValue">EntityValue</nt>production
          allows the definition of a general entity consisting of a
          single explicit 
          <code>&lt;</code>in the literal (e.g., 
          <code>&lt;!ENTITY mylt "&lt;"&gt;</code>), it is strongly
          advised to avoid this practice since any reference to
          that entity will cause a well-formedness error.</p>
        </note>
      </div2>
      <div2 id="syntax">
        <head>Character Data and Markup</head>
        <p>
        <termref def="dt-text">Text</termref>consists of
        intermingled 
        <termref def="dt-chardata">character data</termref>and
        markup. 
        <termdef id="dt-markup" term="Markup">
        <term>Markup</term>takes the form of 
        <termref def="dt-stag">start-tags</termref>, 
        <termref def="dt-etag">end-tags</termref>, 
        <termref def="dt-empty">empty-element tags</termref>, 
        <termref def="dt-entref">entity references</termref>, 
        <termref def="dt-charref">character references</termref>, 
        <termref def="dt-comment">comments</termref>, 
        <termref def="dt-cdsection">CDATA
        section</termref>delimiters, 
        <termref def="dt-doctype">document type
        declarations</termref>, 
        <termref def="dt-pi">processing instructions</termref>, 
        <nt def="NT-XMLDecl">XML declarations</nt>, 
        <nt def="NT-TextDecl">text declarations</nt>, and any white
        space that is at the top level of the document entity (that
        is, outside the document element and not inside any other
        markup).</termdef></p>
        <p>
          <termdef id="dt-chardata" term="Character Data">All text
          that is not markup constitutes the 
          <term>character data</term>of the document.</termdef>
        </p>
        <p>The ampersand character (&amp;) and the left angle
        bracket (&lt;) 
        <rfc2119>MUST NOT</rfc2119>appear in their literal form,
        except when used as markup delimiters, or within a 
        <termref def="dt-comment">comment</termref>, a 
        <termref def="dt-pi">processing instruction</termref>, or a
        
        <termref def="dt-cdsection">CDATA section</termref>. If
        they are needed elsewhere, they 
        <rfc2119>MUST</rfc2119>be 
        <termref def="dt-escape">escaped</termref>using either 
        <termref def="dt-charref">numeric character
        references</termref>or the strings 
        <quote>
          <code>&amp;amp;</code>
        </quote>and 
        <quote>
          <code>&amp;lt;</code>
        </quote>respectively. The right angle bracket (&gt;) may be
        represented using the string 
        <quote>
          <code>&amp;gt;</code>
        </quote>, and 
        <rfc2119>MUST</rfc2119>, 
        <termref def="dt-compat">for compatibility</termref>, be
        escaped using either 
        <quote>
          <code>&amp;gt;</code>
        </quote>or a character reference when it appears in the
        string 
        <quote>
          <code>]]&gt;</code>
        </quote>in content, when that string is not marking the end
        of a 
        <termref def="dt-cdsection">CDATA section</termref>.</p>
        <p>In the content of elements, character data is any string
        of characters which does not contain the start-delimiter of
        any markup and does not include the CDATA-section-close
        delimiter, 
        <quote>
          <code>]]&gt;</code>
        </quote>. In a CDATA section, character data is any string
        of characters not including the CDATA-section-close
        delimiter, 
        <quote>
          <code>]]&gt;</code>
        </quote>.</p>
        <p>To allow attribute values to contain both single and
        double quotes, the apostrophe or single-quote character (')
        may be represented as 
        <quote>
          <code>&amp;apos;</code>
        </quote>, and the double-quote character (") as 
        <quote>
          <code>&amp;quot;</code>
        </quote>.</p>
        <scrap lang="ebnf">
          <head>Character Data</head>
          <prod id="NT-CharData" num="14">
            <lhs>CharData</lhs>
            <rhs>[^&lt;&amp;]* - ([^&lt;&amp;]* ']]&gt;'
            [^&lt;&amp;]*)</rhs>
          </prod>
        </scrap>
      </div2>
      <div2 id="sec-comments">
        <head>Comments</head>
        <p>
        <termdef id="dt-comment" term="Comment">
        <term>Comments</term>may appear anywhere in a document
        outside other 
        <termref def="dt-markup">markup</termref>; in addition,
        they may appear within the document type declaration at
        places allowed by the grammar. They are not part of the
        document's 
        <termref def="dt-chardata">character data</termref>; an XML
        processor 
        <rfc2119>MAY</rfc2119>, but need not, make it possible for
        an application to retrieve the text of comments. 
        <termref def="dt-compat">For compatibility</termref>, the
        string 
        <quote>
          <code>--</code>
        </quote>(double-hyphen) 
        <rfc2119>MUST NOT</rfc2119>occur within
        comments.</termdef>Parameter entity references 
        <rfc2119>MUST NOT</rfc2119>be recognized within
        comments.</p>
        <scrap lang="ebnf">
          <head>Comments</head>
          <prod id="NT-Comment" num="15">
            <lhs>Comment</lhs>
            <rhs>'&lt;!--' ((
            <nt def="NT-Char">Char</nt>- '-') | ('-' (
            <nt def="NT-Char">Char</nt>- '-')))* '--&gt;'</rhs>
          </prod>
        </scrap>
        <p>An example of a comment:</p>
        <eg>&lt;!-- declarations for &lt;head&gt; &amp;
        &lt;body&gt; --&gt;</eg>
        <p>Note that the grammar does not allow a comment ending in
        
        <code>---&gt;</code>. The following example is 
        <emph>not</emph>well-formed.</p>
        <eg>&lt;!-- B+, B, or B---&gt;</eg>
      </div2>
      <div2 id="sec-pi">
        <head>Processing Instructions</head>
        <p>
          <termdef id="dt-pi" term="Processing instruction">
          <term>Processing instructions</term>(PIs) allow documents
          to contain instructions for applications.</termdef>
        </p>
        <scrap lang="ebnf">
          <head>Processing Instructions</head>
          <prod id="NT-PI" num="16">
            <lhs>PI</lhs>
            <rhs>'&lt;?' 
            <nt def="NT-PITarget">PITarget</nt>(
            <nt def="NT-S">S</nt>(
            <nt def="NT-Char">Char</nt>* - (
            <nt def="NT-Char">Char</nt>* '?&gt;' 
            <nt def="NT-Char">Char</nt>*)))? '?&gt;'</rhs>
          </prod>
          <prod id="NT-PITarget" num="17">
            <lhs>PITarget</lhs>
            <rhs>
            <nt def="NT-Name">Name</nt>- (('X' | 'x') ('M' | 'm')
            ('L' | 'l'))</rhs>
          </prod>
        </scrap>
        <p>PIs are not part of the document's 
        <termref def="dt-chardata">character data</termref>, but 
        <rfc2119>MUST</rfc2119>be passed through to the
        application. The PI begins with a target (
        <nt def="NT-PITarget">PITarget</nt>) used to identify the
        application to which the instruction is directed. The
        target names 
        <quote>
          <code>XML</code>
        </quote>, 
        <quote>
          <code>xml</code>
        </quote>, and so on are reserved for standardization in
        this or future versions of this specification. The XML 
        <termref def="dt-notation">Notation</termref>mechanism may
        be used for formal declaration of PI targets. Parameter
        entity references 
        <rfc2119>MUST NOT</rfc2119>be recognized within processing
        instructions.</p>
      </div2>
      <div2 id="sec-cdata-sect">
        <head>CDATA Sections</head>
        <p>
          <termdef id="dt-cdsection" term="CDATA Section">
          <term>CDATA sections</term>may occur anywhere character
          data may occur; they are used to escape blocks of text
          containing characters which would otherwise be recognized
          as markup. CDATA sections begin with the string 
          <quote>
            <code>&lt;![CDATA[</code>
          </quote>and end with the string 
          <quote>
            <code>]]&gt;</code>
          </quote>:</termdef>
        </p>
        <scrap lang="ebnf">
          <head>CDATA Sections</head>
          <prod id="NT-CDSect" num="18">
            <lhs>CDSect</lhs>
            <rhs>
              <nt def="NT-CDStart">CDStart</nt>
              <nt def="NT-CData">CData</nt>
              <nt def="NT-CDEnd">CDEnd</nt>
            </rhs>
          </prod>
          <prod id="NT-CDStart" num="19">
            <lhs>CDStart</lhs>
            <rhs>'&lt;![CDATA['</rhs>
          </prod>
          <prod id="NT-CData" num="20">
            <lhs>CData</lhs>
            <rhs>(
            <nt def="NT-Char">Char</nt>* - (
            <nt def="NT-Char">Char</nt>* ']]&gt;' 
            <nt def="NT-Char">Char</nt>*))</rhs>
          </prod>
          <prod id="NT-CDEnd" num="21">
            <lhs>CDEnd</lhs>
            <rhs>']]&gt;'</rhs>
          </prod>
        </scrap>
        <p>Within a CDATA section, only the 
        <nt def="NT-CDEnd">CDEnd</nt>string is recognized as
        markup, so that left angle brackets and ampersands may
        occur in their literal form; they need not (and cannot) be
        escaped using 
        <quote>
          <code>&amp;lt;</code>
        </quote>and 
        <quote>
          <code>&amp;amp;</code>
        </quote>. CDATA sections cannot nest.</p>
        <p>An example of a CDATA section, in which 
        <quote>
          <code>&lt;greeting&gt;</code>
        </quote>and 
        <quote>
          <code>&lt;/greeting&gt;</code>
        </quote>are recognized as 
        <termref def="dt-chardata">character data</termref>, not 
        <termref def="dt-markup">markup</termref>:</p>
        <eg>&lt;![CDATA[&lt;greeting&gt;Hello,
        world!&lt;/greeting&gt;]]&gt;</eg>
      </div2>
      <div2 id="sec-prolog-dtd">
        <head>Prolog and Document Type Declaration</head>
        <p>
        <termdef id="dt-xmldecl" term="XML Declaration">XML
        documents 
        <rfc2119>SHOULD</rfc2119>begin with an 
        <term>XML declaration</term>which specifies the version of
        XML being used.</termdef>For example, the following is a
        complete XML document, 
        <termref def="dt-wellformed">well-formed</termref>but not 
        <termref def="dt-valid">valid</termref>:</p>
        <eg>&lt;?xml version="1.0"?&gt; &lt;greeting&gt;Hello,
        world!&lt;/greeting&gt;</eg>
        <p>and so is this:</p>
        <eg>&lt;greeting&gt;Hello, world!&lt;/greeting&gt;</eg>
        <p>The function of the markup in an XML document is to
        describe its storage and logical structure and to associate
        attribute name-value pairs with its logical structures. XML
        provides a mechanism, the 
        <termref def="dt-doctype">document type
        declaration</termref>, to define constraints on the logical
        structure and to support the use of predefined storage
        units. 
        <termdef id="dt-valid" term="Validity">An XML document is 
        <term>valid</term>if it has an associated document type
        declaration and if the document complies with the
        constraints expressed in it.</termdef></p>
        <p>The document type declaration 
        <rfc2119>MUST</rfc2119>appear before the first 
        <termref def="dt-element">element</termref>in the
        document.</p>
        <scrap id="xmldoc" lang="ebnf">
          <head>Prolog</head>
          <prodgroup pcw2="6" pcw4="17.5" pcw5="9">
            <prod id="NT-prolog" num="22">
              <lhs>prolog</lhs>
              <rhs>
              <nt def="NT-XMLDecl">XMLDecl</nt>? 
              <nt def="NT-Misc">Misc</nt>* (
              <nt def="NT-doctypedecl">doctypedecl</nt>
              <nt def="NT-Misc">Misc</nt>*)?</rhs>
            </prod>
            <prod id="NT-XMLDecl" num="23">
              <lhs>XMLDecl</lhs>
              <rhs>'&lt;?xml' 
              <nt def="NT-VersionInfo">VersionInfo</nt>
              <nt def="NT-EncodingDecl">EncodingDecl</nt>? 
              <nt def="NT-SDDecl">SDDecl</nt>? 
              <nt def="NT-S">S</nt>? '?&gt;'</rhs>
            </prod>
            <prod id="NT-VersionInfo" num="24">
              <lhs>VersionInfo</lhs>
              <rhs>
              <nt def="NT-S">S</nt>'version' 
              <nt def="NT-Eq">Eq</nt>("'" 
              <nt def="NT-VersionNum">VersionNum</nt>"'" | '"' 
              <nt def="NT-VersionNum">VersionNum</nt>'"')</rhs>
            </prod>
            <prod id="NT-Eq" num="25">
              <lhs>Eq</lhs>
              <rhs>
              <nt def="NT-S">S</nt>? '=' 
              <nt def="NT-S">S</nt>?</rhs>
            </prod>
            <prod id="NT-VersionNum" num="26">
              <lhs>VersionNum</lhs>
              <rhs diff="chg">'1.' [0-9]+</rhs>
              <com diff="chg">
                <loc role="erratumref" href="E10" />
              </com>
            </prod>
            <prod id="NT-Misc" num="27">
              <lhs>Misc</lhs>
              <rhs>
              <nt def="NT-Comment">Comment</nt>| 
              <nt def="NT-PI">PI</nt>| 
              <nt def="NT-S">S</nt></rhs>
            </prod>
          </prodgroup>
        </scrap>
        <p diff="add">
        <loc role="erratumref" href="E10" />Even though the 
        <nt def="NT-VersionNum">VersionNum</nt>production matches
        any version number of the form '1.x', XML 1.0 documents 
        <rfc2119>SHOULD NOT</rfc2119>specify a version number other
        than '1.0'.</p>
        <note diff="add">
          <p>
          <loc role="erratumref" href="E10" />When an XML 1.0
          processor encounters a document that specifies a 1.x
          version number other than '1.0', it will process it as a
          1.0 document. This means that an XML 1.0 processor will
          accept 1.x documents provided they do not use any non-1.0
          features.</p>
        </note>
        <p>
          <termdef id="dt-doctype"
          term="Document Type Declaration">The XML 
          <term>document type declaration</term>contains or points
          to 
          <termref def="dt-markupdecl">markup
          declarations</termref>that provide a grammar for a class
          of documents. This grammar is known as a document type
          definition, or 
          <term>DTD</term>. The document type declaration can point
          to an external subset (a special kind of 
          <termref def="dt-extent">external entity</termref>)
          containing markup declarations, or can contain the markup
          declarations directly in an internal subset, or can do
          both. The DTD for a document consists of both subsets
          taken together.</termdef>
        </p>
        <p>
        <termdef id="dt-markupdecl" term="markup declaration">A 
        <term>markup declaration</term>is an 
        <termref def="dt-eldecl">element type
        declaration</termref>, an 
        <termref def="dt-attdecl">attribute-list
        declaration</termref>, an 
        <termref def="dt-entdecl">entity declaration</termref>, or
        a 
        <termref def="dt-notdecl">notation
        declaration</termref>.</termdef>These declarations may be
        contained in whole or in part within 
        <termref def="dt-PE">parameter entities</termref>, as
        described in the well-formedness and validity constraints
        below. For further information, see 
        <specref ref="sec-physical-struct" />.</p>
        <scrap id="dtd" lang="ebnf">
          <head>Document Type Definition</head>
          <prodgroup pcw2="6" pcw4="17.5" pcw5="9">
            <prod id="NT-doctypedecl" num="28">
              <lhs>doctypedecl</lhs>
              <rhs>'&lt;!DOCTYPE' 
              <nt def="NT-S">S</nt>
              <nt def="NT-Name">Name</nt>(
              <nt def="NT-S">S</nt>
              <nt def="NT-ExternalID">ExternalID</nt>)? 
              <nt def="NT-S">S</nt>? ('[' 
              <nt def="NT-intSubset">intSubset</nt>']' 
              <nt def="NT-S">S</nt>?)? '&gt;'</rhs>
              <vc def="vc-roottype" />
              <wfc def="ExtSubset" />
            </prod>
            <prod id="NT-DeclSep" num="28a">
              <lhs>DeclSep</lhs>
              <rhs>
              <nt def="NT-PEReference">PEReference</nt>| 
              <nt def="NT-S">S</nt></rhs>
              <wfc def="PE-between-Decls" />
            </prod>
            <prod id="NT-intSubset" num="28b">
              <lhs>intSubset</lhs>
              <rhs>(
              <nt def="NT-markupdecl">markupdecl</nt>| 
              <nt def="NT-DeclSep">DeclSep</nt>)*</rhs>
            </prod>
            <prod id="NT-markupdecl" num="29">
              <lhs>markupdecl</lhs>
              <rhs>
              <nt def="NT-elementdecl">elementdecl</nt>| 
              <nt def="NT-AttlistDecl">AttlistDecl</nt>| 
              <nt def="NT-EntityDecl">EntityDecl</nt>| 
              <nt def="NT-NotationDecl">NotationDecl</nt>| 
              <nt def="NT-PI">PI</nt>| 
              <nt def="NT-Comment">Comment</nt></rhs>
              <vc def="vc-PEinMarkupDecl" />
              <wfc def="wfc-PEinInternalSubset" />
            </prod>
          </prodgroup>
        </scrap>
        <p>Note that it is possible to construct a well-formed
        document containing a 
        <nt def="NT-doctypedecl">doctypedecl</nt>that neither
        points to an external subset nor contains an internal
        subset.</p>
        <p>The markup declarations may be made up in whole or in
        part of the 
        <termref def="dt-repltext">replacement text</termref>of 
        <termref def="dt-PE">parameter entities</termref>. The
        productions later in this specification for individual
        nonterminals (
        <nt def="NT-elementdecl">elementdecl</nt>, 
        <nt def="NT-AttlistDecl">AttlistDecl</nt>, and so on)
        describe the declarations 
        <emph>after</emph>all the parameter entities have been 
        <termref def="dt-include">included</termref>.</p>
        <p>Parameter entity references are recognized anywhere in
        the DTD (internal and external subsets and external
        parameter entities), except in literals, processing
        instructions, comments, and the contents of ignored
        conditional sections (see 
        <specref ref="sec-condition-sect" />). They are also
        recognized in entity value literals. The use of parameter
        entities in the internal subset is restricted as described
        below.</p>
        <vcnote id="vc-roottype">
          <head>Root Element Type</head>
          <p>The 
          <nt def="NT-Name">Name</nt>in the document type
          declaration 
          <rfc2119>MUST</rfc2119>match the element type of the 
          <termref def="dt-root">root element</termref>.</p>
        </vcnote>
        <vcnote id="vc-PEinMarkupDecl">
          <head>Proper Declaration/PE Nesting</head>
          <p>Parameter-entity 
          <termref def="dt-repltext">replacement text</termref>
          <rfc2119>MUST</rfc2119>be properly nested with markup
          declarations. That is to say, if either the first
          character or the last character of a markup declaration (
          <nt def="NT-markupdecl">markupdecl</nt>above) is
          contained in the replacement text for a 
          <termref def="dt-PERef">parameter-entity
          reference</termref>, both 
          <rfc2119>MUST</rfc2119>be contained in the same
          replacement text.</p>
        </vcnote>
        <wfcnote id="wfc-PEinInternalSubset">
          <head>PEs in Internal Subset</head>
          <p>In the internal DTD subset, 
          <termref def="dt-PERef">parameter-entity
          references</termref>
          <rfc2119>MUST NOT</rfc2119>occur within markup
          declarations; they may occur where markup declarations
          can occur. (This does not apply to references that occur
          in external parameter entities or to the external
          subset.)</p>
        </wfcnote>
        <wfcnote id="ExtSubset">
          <head>External Subset</head>
          <p>The external subset, if any, 
          <rfc2119>MUST</rfc2119>match the production for 
          <nt def="NT-extSubset">extSubset</nt>.</p>
        </wfcnote>
        <wfcnote id="PE-between-Decls">
          <head>PE Between Declarations</head>
          <p>The replacement text of a parameter entity reference
          in a 
          <nt def="NT-DeclSep">DeclSep</nt>
          <rfc2119>MUST</rfc2119>match the production 
          <nt def="NT-extSubsetDecl">extSubsetDecl</nt>.</p>
        </wfcnote>
        <p>Like the internal subset, the external subset and any
        external parameter entities referenced in a 
        <nt def="NT-DeclSep">DeclSep</nt>
        <rfc2119>MUST</rfc2119>consist of a series of complete
        markup declarations of the types allowed by the
        non-terminal symbol 
        <nt def="NT-markupdecl">markupdecl</nt>, interspersed with
        white space or 
        <termref def="dt-PERef">parameter-entity
        references</termref>. However, portions of the contents of
        the external subset or of these external parameter entities
        may conditionally be ignored by using the 
        <termref def="dt-cond-section">conditional
        section</termref>construct; this is not allowed in the
        internal subset but is allowed in external parameter
        entities referenced in the internal subset.</p>
        <scrap id="ext-Subset" lang="ebnf">
          <head>External Subset</head>
          <prodgroup pcw2="6" pcw4="17.5" pcw5="9">
            <prod id="NT-extSubset" num="30">
              <lhs>extSubset</lhs>
              <rhs>
              <nt def="NT-TextDecl">TextDecl</nt>? 
              <nt def="NT-extSubsetDecl">extSubsetDecl</nt></rhs>
            </prod>
            <prod id="NT-extSubsetDecl" num="31">
              <lhs>extSubsetDecl</lhs>
              <rhs>( 
              <nt def="NT-markupdecl">markupdecl</nt>| 
              <nt def="NT-conditionalSect">conditionalSect</nt>| 
              <nt def="NT-DeclSep">DeclSep</nt>)*</rhs>
            </prod>
          </prodgroup>
        </scrap>
        <p>The external subset and external parameter entities also
        differ from the internal subset in that in them, 
        <termref def="dt-PERef">parameter-entity
        references</termref>are permitted 
        <emph>within</emph>markup declarations, not only 
        <emph>between</emph>markup declarations.</p>
        <p>An example of an XML document with a document type
        declaration:</p>
        <eg>&lt;?xml version="1.0"?&gt; &lt;!DOCTYPE greeting
        SYSTEM "hello.dtd"&gt; &lt;greeting&gt;Hello,
        world!&lt;/greeting&gt;</eg>
        <p>The 
        <termref def="dt-sysid">system identifier</termref>
        <quote>
          <code>hello.dtd</code>
        </quote>gives the address (a URI reference) of a DTD for
        the document.</p>
        <p>The declarations can also be given locally, as in this
        example:</p>
        <eg>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
        &lt;!DOCTYPE greeting [ &lt;!ELEMENT greeting (#PCDATA)&gt;
        ]&gt; &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</eg>
        <p>If both the external and internal subsets are used, the
        internal subset 
        <rfc2119>MUST</rfc2119>be considered to occur before the
        external subset. This has the effect that entity and
        attribute-list declarations in the internal subset take
        precedence over those in the external subset.</p>
      </div2>
      <div2 id="sec-rmd">
        <head>Standalone Document Declaration</head>
        <p>Markup declarations can affect the content of the
        document, as passed from an 
        <termref def="dt-xml-proc">XML processor</termref>to an
        application; examples are attribute defaults and entity
        declarations. The standalone document declaration, which
        may appear as a component of the XML declaration, signals
        whether or not there are such declarations which appear
        external to the 
        <termref def="dt-docent">document entity</termref>or in
        parameter entities. 
        <termdef id="dt-extmkpdecl"
        term="External Markup Declaration">An 
        <term>external markup declaration</term>is defined as a
        markup declaration occurring in the external subset or in a
        parameter entity (external or internal, the latter being
        included because non-validating processors are not required
        to read them).</termdef></p>
        <scrap id="fulldtd" lang="ebnf">
          <head>Standalone Document Declaration</head>
          <prodgroup pcw2="4" pcw4="19.5" pcw5="9">
            <prod id="NT-SDDecl" num="32">
              <lhs>SDDecl</lhs>
              <rhs>
              <nt def="NT-S">S</nt>'standalone' 
              <nt def="NT-Eq">Eq</nt>(("'" ('yes' | 'no') "'") |
              ('"' ('yes' | 'no') '"'))</rhs>
              <vc def="vc-check-rmd" />
            </prod>
          </prodgroup>
        </scrap>
        <p>In a standalone document declaration, the value 
        <attval>yes</attval>indicates that there are no 
        <termref def="dt-extmkpdecl">external markup
        declarations</termref>which affect the information passed
        from the XML processor to the application. The value 
        <attval>no</attval>indicates that there are or may be such
        external markup declarations. Note that the standalone
        document declaration only denotes the presence of external 
        <emph>declarations</emph>; the presence, in a document, of
        references to external 
        <emph>entities</emph>, when those entities are internally
        declared, does not change its standalone status.</p>
        <p>If there are no external markup declarations, the
        standalone document declaration has no meaning. If there
        are external markup declarations but there is no standalone
        document declaration, the value 
        <attval>no</attval>is assumed.</p>
        <p>Any XML document for which 
        <code>standalone="no"</code>holds can be converted
        algorithmically to a standalone document, which may be
        desirable for some network delivery applications.</p>
        <vcnote id="vc-check-rmd">
          <head>Standalone Document Declaration</head>
          <p>The standalone document declaration 
          <rfc2119>MUST</rfc2119>have the value 
          <attval>no</attval>if any external markup declarations
          contain declarations of:</p>
          <ulist>
            <item>
              <p>attributes with 
              <termref def="dt-default">default</termref>values, if
              elements to which these attributes apply appear in
              the document without specifications of values for
              these attributes, or</p>
            </item>
            <item>
              <p>entities (other than 
              <code>amp</code>, 
              <code>lt</code>, 
              <code>gt</code>, 
              <code>apos</code>, 
              <code>quot</code>), if 
              <termref def="dt-entref">references</termref>to those
              entities appear in the document, or</p>
            </item>
            <item>
              <p>attributes with tokenized types, where the
              attribute appears in the document with a value such
              that 
              <titleref href="#AVNormalize">
              normalization</titleref>will produce a different
              value from that which would be produced in the
              absence of the declaration, or</p>
            </item>
            <item>
              <p>element types with 
              <termref def="dt-elemcontent">element
              content</termref>, if white space occurs directly
              within any instance of those types.</p>
            </item>
          </ulist>
        </vcnote>
        <p>An example XML declaration with a standalone document
        declaration:</p>
        <eg>&lt;?xml version="1.0" standalone='yes'?&gt;</eg>
      </div2>
      <div2 id="sec-white-space">
        <head>White Space Handling</head>
        <p>In editing XML documents, it is often convenient to use 
        <quote>white space</quote>(spaces, tabs, and blank lines)
        to set apart the markup for greater readability. Such white
        space is typically not intended for inclusion in the
        delivered version of the document. On the other hand, 
        <quote>significant</quote>white space that should be
        preserved in the delivered version is common, for example
        in poetry and source code.</p>
        <p>An 
        <termref def="dt-xml-proc">XML processor</termref>
        <rfc2119>MUST</rfc2119>always pass all characters in a
        document that are not markup through to the application. A 
        <termref def="dt-validating">validating XML
        processor</termref>
        <rfc2119>MUST</rfc2119>also inform the application which of
        these characters constitute white space appearing in 
        <termref def="dt-elemcontent">element
        content</termref>.</p>
        <p>A special 
        <termref def="dt-attr">attribute</termref>named 
        <att>xml:space</att>may be attached to an element to signal
        an intention that in that element, white space should be
        preserved by applications. In valid documents, this
        attribute, like any other, 
        <rfc2119>MUST</rfc2119>be 
        <termref def="dt-attdecl">declared</termref>if it is used.
        When declared, it 
        <rfc2119>MUST</rfc2119>be given as an 
        <termref def="dt-enumerated">enumerated type</termref>whose
        values are one or both of 
        <attval>default</attval>and 
        <attval>preserve</attval>. For example:</p>
        <eg>&lt;!ATTLIST poem xml:space (default|preserve)
        'preserve'&gt; &lt;!ATTLIST pre xml:space (preserve) #FIXED
        'preserve'&gt;</eg>
        <p>The value 
        <attval>default</attval>signals that applications' default
        white-space processing modes are acceptable for this
        element; the value 
        <attval>preserve</attval>indicates the intent that
        applications preserve all the white space. This declared
        intent is considered to apply to all elements within the
        content of the element where it is specified, unless
        overridden with another instance of the 
        <att>xml:space</att>attribute. This specification does not
        give meaning to any value of 
        <att>xml:space</att>other than 
        <attval>default</attval>and 
        <attval>preserve</attval>. It is an error for other values
        to be specified; the XML processor 
        <rfc2119>MAY</rfc2119>report the error or 
        <rfc2119>MAY</rfc2119>recover by ignoring the attribute
        specification or by reporting the (erroneous) value to the
        application. Applications may ignore or reject erroneous
        values.</p>
        <p>The 
        <termref def="dt-root">root element</termref>of any
        document is considered to have signaled no intentions as
        regards application space handling, unless it provides a
        value for this attribute or the attribute is declared with
        a default value.</p>
      </div2>
      <div2 id="sec-line-ends">
        <head>End-of-Line Handling</head>
        <p>XML 
        <termref def="dt-parsedent">parsed entities</termref>are
        often stored in computer files which, for editing
        convenience, are organized into lines. These lines are
        typically separated by some combination of the characters
        CARRIAGE RETURN (#xD) and LINE FEED (#xA).</p>
        <p>To simplify the tasks of 
        <termref def="dt-app">applications</termref>, the 
        <termref def="dt-xml-proc">XML processor</termref>
        <rfc2119>MUST</rfc2119>behave as if it normalized all line
        breaks in external parsed entities (including the document
        entity) on input, before parsing, by translating both the
        two-character sequence #xD #xA and any #xD that is not
        followed by #xA to a single #xA character.</p>
      </div2>
      <div2 id="sec-lang-tag">
        <head>Language Identification</head>
        <p>In document processing, it is often useful to identify
        the natural or formal language in which the content is
        written. A special 
        <termref def="dt-attr">attribute</termref>named 
        <att>xml:lang</att>may be inserted in documents to specify
        the language used in the contents and attribute values of
        any element in an XML document. In valid documents, this
        attribute, like any other, 
        <rfc2119>MUST</rfc2119>be 
        <termref def="dt-attdecl">declared</termref>if it is used.
        The values of the attribute are language identifiers as
        defined by 
        <bibref ref="RFC1766" />, 
        <titleref>Tags for the Identification of
        Languages</titleref>
        <phrase diff="del">, or its successor</phrase>; in
        addition, the empty string may be specified.</p>
        <p>(Productions 33 through 38 have been removed.)</p>
        <p>For example:</p>
        <eg>&lt;p xml:lang="en"&gt;The quick brown fox jumps over
        the lazy dog.&lt;/p&gt; &lt;p xml:lang="en-GB"&gt;What
        colour is it?&lt;/p&gt; &lt;p xml:lang="en-US"&gt;What
        color is it?&lt;/p&gt; &lt;sp who="Faust" desc='leise'
        xml:lang="de"&gt; &lt;l&gt;Habe nun, ach!
        Philosophie,&lt;/l&gt; &lt;l&gt;Juristerei, und
        Medizin&lt;/l&gt; &lt;l&gt;und leider auch
        Theologie&lt;/l&gt; &lt;l&gt;durchaus studiert mit
        hei&#195;&#376;em Bem&#195;&#188;h'n.&lt;/l&gt;
        &lt;/sp&gt;</eg>
        <p>The language specified by 
        <att>xml:lang</att>applies to the element where it is
        specified (including the values of its attributes), and to
        all elements in its content unless overridden with another
        instance of 
        <att>xml:lang</att>. In particular, the empty value of 
        <att>xml:lang</att>is used on an element B to override a
        specification of 
        <att>xml:lang</att>on an enclosing element A, without
        specifying another language. Within B, it is considered
        that there is no language information available, just as if
        
        <att>xml:lang</att>had not been specified on B or any of
        its ancestors. Applications determine which of an element's
        attribute values and which parts of its character content,
        if any, are treated as language-dependent values described
        by 
        <att>xml:lang</att>.</p>
        <note>
          <p>Language information may also be provided by external
          transport protocols (e.g. HTTP or MIME). When available,
          this information may be used by XML applications, but the
          more local information provided by 
          <att>xml:lang</att>should be considered to override
          it.</p>
        </note>
        <p>A simple declaration for 
        <att>xml:lang</att>might take the form</p>
        <eg>xml:lang CDATA #IMPLIED</eg>
        <p>but specific default values may also be given, if
        appropriate. In a collection of French poems for English
        students, with glosses and notes in English, the 
        <att>xml:lang</att>attribute might be declared this
        way:</p>
        <eg>&lt;!ATTLIST poem xml:lang CDATA 'fr'&gt; &lt;!ATTLIST
        gloss xml:lang CDATA 'en'&gt; &lt;!ATTLIST note xml:lang
        CDATA 'en'&gt;</eg>
      </div2>
    </div1>
    <div1 id="sec-logical-struct">
      <head>Logical Structures</head>
      <p>
      <termdef id="dt-element" term="Element">Each 
      <termref def="dt-xml-doc">XML document</termref>contains one
      or more 
      <term>elements</term>, the boundaries of which are either
      delimited by 
      <termref def="dt-stag">start-tags</termref>and 
      <termref def="dt-etag">end-tags</termref>, or, for 
      <termref def="dt-empty">empty</termref>elements, by an 
      <termref def="dt-eetag">empty-element tag</termref>. Each
      element has a type, identified by name, sometimes called its 
      <quote>generic identifier</quote>(GI), and may have a set of
      attribute specifications.</termdef>Each attribute
      specification has a 
      <termref def="dt-attrname">name</termref>and a 
      <termref def="dt-attrval">value</termref>.</p>
      <scrap lang="ebnf">
        <head>Element</head>
        <prod id="NT-element" num="39">
          <lhs>element</lhs>
          <rhs>
            <nt def="NT-EmptyElemTag">EmptyElemTag</nt>
          </rhs>
          <rhs>| 
          <nt def="NT-STag">STag</nt>
          <nt def="NT-content">content</nt>
          <nt def="NT-ETag">ETag</nt></rhs>
          <wfc def="GIMatch" />
          <vc def="elementvalid" />
        </prod>
      </scrap>
      <p>This specification does not constrain the application
      semantics, use, or (beyond syntax) names of the element types
      and attributes, except that names beginning with a match to 
      <code>(('X'|'x')('M'|'m')('L'|'l'))</code>are reserved for
      standardization in this or future versions of this
      specification.</p>
      <wfcnote id="GIMatch">
        <head>Element Type Match</head>
        <p>The 
        <nt def="NT-Name">Name</nt>in an element's end-tag 
        <rfc2119>MUST</rfc2119>match the element type in the
        start-tag.</p>
      </wfcnote>
      <vcnote id="elementvalid">
        <head>Element Valid</head>
        <p>An element is valid if there is a declaration matching 
        <nt def="NT-elementdecl">elementdecl</nt>where the 
        <nt def="NT-Name">Name</nt>matches the element type, and
        one of the following holds:</p>
        <olist>
          <item>
            <p>The declaration matches 
            <kw>EMPTY</kw>and the element has no 
            <termref def="dt-content">content</termref>(not even
            entity references, comments, PIs or white space).</p>
          </item>
          <item>
            <p>The declaration matches 
            <nt def="NT-children">children</nt>and the sequence of 
            <termref def="dt-parentchild">child
            elements</termref>belongs to the language generated by
            the regular expression in the content model, with
            optional white space, comments and PIs (i.e. markup
            matching production [27] 
            <nt def="NT-Misc">Misc</nt>) between the start-tag and
            the first child element, between child elements, or
            between the last child element and the end-tag. Note
            that a CDATA section containing only white space or a
            reference to an entity whose replacement text is
            character references expanding to white space do not
            match the nonterminal 
            <nt def="NT-S">S</nt>, and hence cannot appear in these
            positions; however, a reference to an internal entity
            with a literal value consisting of character references
            expanding to white space does match 
            <nt def="NT-S">S</nt>, since its replacement text is
            the white space resulting from expansion of the
            character references.</p>
          </item>
          <item>
            <p>The declaration matches 
            <nt def="NT-Mixed">Mixed</nt>, and the content (after
            replacing any entity references with their replacement
            text) consists of 
            <termref def="dt-chardata">character
            data</termref>(including 
            <termref def="dt-cdsection">CDATA sections</termref>), 
            <termref def="dt-comment">comments</termref>, 
            <termref def="dt-pi">PIs</termref>and 
            <termref def="dt-parentchild">child
            elements</termref>whose types match names in the
            content model.</p>
          </item>
          <item>
            <p>The declaration matches 
            <kw>ANY</kw>, and the content (after replacing any
            entity references with their replacement text) consists
            of character data, 
            <termref def="dt-cdsection">CDATA sections</termref>, 
            <termref def="dt-comment">comments</termref>, 
            <termref def="dt-pi">PIs</termref>and 
            <termref def="dt-parentchild">child
            elements</termref>whose types have been declared.</p>
          </item>
        </olist>
      </vcnote>
      <div2 id="sec-starttags">
        <head>Start-Tags, End-Tags, and Empty-Element Tags</head>
        <p>
          <termdef id="dt-stag" term="Start-Tag">The beginning of
          every non-empty XML element is marked by a 
          <term>start-tag</term>.</termdef>
        </p>
        <scrap lang="ebnf">
          <head>Start-tag</head>
          <prodgroup pcw2="6" pcw4="15" pcw5="11.5">
            <prod id="NT-STag" num="40">
              <lhs>STag</lhs>
              <rhs>'&lt;' 
              <nt def="NT-Name">Name</nt>(
              <nt def="NT-S">S</nt>
              <nt def="NT-Attribute">Attribute</nt>)* 
              <nt def="NT-S">S</nt>? '&gt;'</rhs>
              <wfc def="uniqattspec" />
            </prod>
            <prod id="NT-Attribute" num="41">
              <lhs>Attribute</lhs>
              <rhs>
                <nt def="NT-Name">Name</nt>
                <nt def="NT-Eq">Eq</nt>
                <nt def="NT-AttValue">AttValue</nt>
              </rhs>
              <vc def="ValueType" />
              <wfc def="NoExternalRefs" />
              <wfc def="CleanAttrVals" />
            </prod>
          </prodgroup>
        </scrap>
        <p>The 
        <nt def="NT-Name">Name</nt>in the start- and end-tags gives
        the element's 
        <term>type</term>. 
        <termdef id="dt-attr" term="Attribute">The 
        <nt def="NT-Name">Name</nt>-
        <nt def="NT-AttValue">AttValue</nt>pairs are referred to as
        the 
        <term>attribute specifications</term>of the
        element</termdef>, 
        <termdef id="dt-attrname" term="Attribute Name">with the 
        <nt def="NT-Name">Name</nt>in each pair referred to as the 
        <term>attribute name</term></termdef>and 
        <termdef id="dt-attrval" term="Attribute Value">the content
        of the 
        <nt def="NT-AttValue">AttValue</nt>(the text between the 
        <code>'</code>or 
        <code>"</code>delimiters) as the 
        <term>attribute value</term>.</termdef>Note that the order
        of attribute specifications in a start-tag or empty-element
        tag is not significant.</p>
        <wfcnote id="uniqattspec">
          <head>Unique Att Spec</head>
          <p>An attribute name 
          <rfc2119>MUST NOT</rfc2119>appear more than once in the
          same start-tag or empty-element tag.</p>
        </wfcnote>
        <vcnote id="ValueType">
          <head>Attribute Value Type</head>
          <p>The attribute 
          <rfc2119>MUST</rfc2119>have been declared; the value 
          <rfc2119>MUST</rfc2119>be of the type declared for it.
          (For attribute types, see 
          <specref ref="attdecls" />.)</p>
        </vcnote>
        <wfcnote id="NoExternalRefs">
          <head>No External Entity References</head>
          <p>Attribute values 
          <rfc2119>MUST NOT</rfc2119>contain direct or indirect
          entity references to external entities.</p>
        </wfcnote>
        <wfcnote id="CleanAttrVals">
          <head>No 
          <code>&lt;</code>in Attribute Values</head>
          <p>The 
          <termref def="dt-repltext">replacement text</termref>of
          any entity referred to directly or indirectly in an
          attribute value 
          <rfc2119>MUST NOT</rfc2119>contain a 
          <code>&lt;</code>.</p>
        </wfcnote>
        <p>An example of a start-tag:</p>
        <eg>&lt;termdef id="dt-dog" term="dog"&gt;</eg>
        <p>
          <termdef id="dt-etag" term="End Tag">The end of every
          element that begins with a start-tag 
          <rfc2119>MUST</rfc2119>be marked by an 
          <term>end-tag</term>containing a name that echoes the
          element's type as given in the start-tag:</termdef>
        </p>
        <scrap lang="ebnf">
          <head>End-tag</head>
          <prodgroup pcw2="6" pcw4="15" pcw5="11.5">
            <prod id="NT-ETag" num="42">
              <lhs>ETag</lhs>
              <rhs>'&lt;/' 
              <nt def="NT-Name">Name</nt>
              <nt def="NT-S">S</nt>? '&gt;'</rhs>
            </prod>
          </prodgroup>
        </scrap>
        <p>An example of an end-tag:</p>
        <eg>&lt;/termdef&gt;</eg>
        <p>
          <termdef id="dt-content" term="Content">The 
          <termref def="dt-text">text</termref>between the
          start-tag and end-tag is called the element's 
          <term>content</term>:</termdef>
        </p>
        <scrap lang="ebnf">
          <head>Content of Elements</head>
          <prodgroup pcw2="6" pcw4="15" pcw5="11.5">
            <prod id="NT-content" num="43">
              <lhs>content</lhs>
              <rhs>
              <nt def="NT-CharData">CharData</nt>? ((
              <nt def="NT-element">element</nt>| 
              <nt def="NT-Reference">Reference</nt>| 
              <nt def="NT-CDSect">CDSect</nt>| 
              <nt def="NT-PI">PI</nt>| 
              <nt def="NT-Comment">Comment</nt>) 
              <nt def="NT-CharData">CharData</nt>?)*</rhs>
            </prod>
          </prodgroup>
        </scrap>
        <p>
        <termdef id="dt-empty" term="Empty">An element with no 
        <nt def="NT-content">content</nt>is said to be 
        <term>empty</term>.</termdef>The representation of an empty
        element is either a start-tag immediately followed by an
        end-tag, or an empty-element tag. 
        <termdef id="dt-eetag" term="empty-element tag">An 
        <term>empty-element tag</term>takes a special
        form:</termdef></p>
        <scrap lang="ebnf">
          <head>Tags for Empty Elements</head>
          <prodgroup pcw2="6" pcw4="15" pcw5="11.5">
            <prod id="NT-EmptyElemTag" num="44">
              <lhs>EmptyElemTag</lhs>
              <rhs>'&lt;' 
              <nt def="NT-Name">Name</nt>(
              <nt def="NT-S">S</nt>
              <nt def="NT-Attribute">Attribute</nt>)* 
              <nt def="NT-S">S</nt>? '/&gt;'</rhs>
              <wfc def="uniqattspec" />
            </prod>
          </prodgroup>
        </scrap>
        <p>Empty-element tags may be used for any element which has
        no content, whether or not it is declared using the keyword
        
        <kw>EMPTY</kw>. 
        <termref def="dt-interop">For interoperability</termref>,
        the empty-element tag 
        <rfc2119>SHOULD</rfc2119>be used, and 
        <rfc2119>SHOULD</rfc2119>only be used, for elements which
        are declared EMPTY.</p>
        <p>Examples of empty elements:</p>
        <eg>&lt;IMG align="left"
        src="http://www.w3.org/Icons/WWW/w3c_home" /&gt;
        &lt;br&gt;&lt;/br&gt; &lt;br/&gt;</eg>
      </div2>
      <div2 id="elemdecls">
        <head>Element Type Declarations</head>
        <p>The 
        <termref def="dt-element">element</termref>structure of an 
        <termref def="dt-xml-doc">XML document</termref>may, for 
        <termref def="dt-valid">validation</termref>purposes, be
        constrained using element type and attribute-list
        declarations. An element type declaration constrains the
        element's 
        <termref def="dt-content">content</termref>.</p>
        <p>Element type declarations often constrain which element
        types can appear as 
        <termref def="dt-parentchild">children</termref>of the
        element. At user option, an XML processor 
        <rfc2119>MAY</rfc2119>issue a warning when a declaration
        mentions an element type for which no declaration is
        provided, but this is not an error.</p>
        <p>
          <termdef id="dt-eldecl" term="Element Type declaration">
          An 
          <term>element type declaration</term>takes the
          form:</termdef>
        </p>
        <scrap lang="ebnf">
          <head>Element Type Declaration</head>
          <prodgroup pcw2="5.5" pcw4="18" pcw5="9">
            <prod id="NT-elementdecl" num="45">
              <lhs>elementdecl</lhs>
              <rhs>'&lt;!ELEMENT' 
              <nt def="NT-S">S</nt>
              <nt def="NT-Name">Name</nt>
              <nt def="NT-S">S</nt>
              <nt def="NT-contentspec">contentspec</nt>
              <nt def="NT-S">S</nt>? '&gt;'</rhs>
              <vc def="EDUnique" />
            </prod>
            <prod id="NT-contentspec" num="46">
              <lhs>contentspec</lhs>
              <rhs>'EMPTY' | 'ANY' | 
              <nt def="NT-Mixed">Mixed</nt>| 
              <nt def="NT-children">children</nt></rhs>
            </prod>
          </prodgroup>
        </scrap>
        <p>where the 
        <nt def="NT-Name">Name</nt>gives the element type being
        declared.</p>
        <vcnote id="EDUnique">
          <head>Unique Element Type Declaration</head>
          <p>An element type 
          <rfc2119>MUST NOT</rfc2119>be declared more than
          once.</p>
        </vcnote>
        <p>Examples of element type declarations:</p>
        <eg>&lt;!ELEMENT br EMPTY&gt; &lt;!ELEMENT p
        (#PCDATA|emph)* &gt; &lt;!ELEMENT %name.para;
        %content.para; &gt; &lt;!ELEMENT container ANY&gt;</eg>
        <div3 id="sec-element-content">
          <head>Element Content</head>
          <p>
          <termdef id="dt-elemcontent" term="Element content">An
          element 
          <termref def="dt-stag">type</termref>has 
          <term>element content</term>when elements of that type 
          <rfc2119>MUST</rfc2119>contain only 
          <termref def="dt-parentchild">child</termref>elements (no
          character data), optionally separated by white space
          (characters matching the nonterminal 
          <nt def="NT-S">S</nt>).</termdef>
          <termdef id="dt-content-model" term="Content model">In
          this case, the constraint includes a 
          <term>content model</term>, a simple grammar governing
          the allowed types of the child elements and the order in
          which they are allowed to appear.</termdef>The grammar is
          built on content particles (
          <nt def="NT-cp">cp</nt>s), which consist of names, choice
          lists of content particles, or sequence lists of content
          particles:</p>
          <scrap lang="ebnf">
            <head>Element-content Models</head>
            <prodgroup pcw2="5.5" pcw4="16" pcw5="11">
              <prod id="NT-children" num="47">
                <lhs>children</lhs>
                <rhs>(
                <nt def="NT-choice">choice</nt>| 
                <nt def="NT-seq">seq</nt>) ('?' | '*' | '+')?</rhs>
              </prod>
              <prod id="NT-cp" num="48">
                <lhs>cp</lhs>
                <rhs>(
                <nt def="NT-Name">Name</nt>| 
                <nt def="NT-choice">choice</nt>| 
                <nt def="NT-seq">seq</nt>) ('?' | '*' | '+')?</rhs>
              </prod>
              <prod id="NT-choice" num="49">
                <lhs>choice</lhs>
                <rhs>'(' 
                <nt def="NT-S">S</nt>? 
                <nt def="NT-cp">cp</nt>( 
                <nt def="NT-S">S</nt>? '|' 
                <nt def="NT-S">S</nt>? 
                <nt def="NT-cp">cp</nt>)+ 
                <nt def="NT-S">S</nt>? ')'</rhs>
                <vc def="vc-PEinGroup" />
              </prod>
              <prod id="NT-seq" num="50">
                <lhs>seq</lhs>
                <rhs>'(' 
                <nt def="NT-S">S</nt>? 
                <nt def="NT-cp">cp</nt>( 
                <nt def="NT-S">S</nt>? ',' 
                <nt def="NT-S">S</nt>? 
                <nt def="NT-cp">cp</nt>)* 
                <nt def="NT-S">S</nt>? ')'</rhs>
                <vc def="vc-PEinGroup" />
              </prod>
            </prodgroup>
          </scrap>
          <p>where each 
          <nt def="NT-Name">Name</nt>is the type of an element
          which may appear as a 
          <termref def="dt-parentchild">child</termref>. Any
          content particle in a choice list may appear in the 
          <termref def="dt-elemcontent">element content</termref>at
          the location where the choice list appears in the
          grammar; content particles occurring in a sequence list 
          <rfc2119>MUST</rfc2119>each appear in the 
          <termref def="dt-elemcontent">element content</termref>in
          the order given in the list. The optional character
          following a name or list governs whether the element or
          the content particles in the list may occur one or more (
          <code>+</code>), zero or more (
          <code>*</code>), or zero or one times (
          <code>?</code>). The absence of such an operator means
          that the element or content particle 
          <rfc2119>MUST</rfc2119>appear exactly once. This syntax
          and meaning are identical to those used in the
          productions in this specification.</p>
          <p>The content of an element matches a content model if
          and only if it is possible to trace out a path through
          the content model, obeying the sequence, choice, and
          repetition operators and matching each element in the
          content against an element type in the content model. 
          <termref def="dt-compat">For compatibility</termref>, it
          is an error if the content model allows an element to
          match more than one occurrence of an element type in the
          content model. For more information, see 
          <specref ref="determinism" />.</p>
          <vcnote id="vc-PEinGroup">
            <head>Proper Group/PE Nesting</head>
            <p>Parameter-entity 
            <termref def="dt-repltext">replacement text</termref>
            <rfc2119>MUST</rfc2119>be properly nested with
            parenthesized groups. That is to say, if either of the
            opening or closing parentheses in a 
            <nt def="NT-choice">choice</nt>, 
            <nt def="NT-seq">seq</nt>, or 
            <nt def="NT-Mixed">Mixed</nt>construct is contained in
            the replacement text for a 
            <termref def="dt-PERef">parameter entity</termref>,
            both 
            <rfc2119>MUST</rfc2119>be contained in the same
            replacement text.</p>
            <p>
            <termref def="dt-interop">For
            interoperability</termref>, if a parameter-entity
            reference appears in a 
            <nt def="NT-choice">choice</nt>, 
            <nt def="NT-seq">seq</nt>, or 
            <nt def="NT-Mixed">Mixed</nt>construct, its replacement
            text 
            <rfc2119>SHOULD</rfc2119>contain at least one non-blank
            character, and neither the first nor last non-blank
            character of the replacement text 
            <rfc2119>SHOULD</rfc2119>be a connector (
            <code>|</code>or 
            <code>,</code>).</p>
          </vcnote>
          <p>Examples of element-content models:</p>
          <eg>&lt;!ELEMENT spec (front, body, back?)&gt;
          &lt;!ELEMENT div1 (head, (p | list | note)*, div2*)&gt;
          &lt;!ELEMENT dictionary-body (%div.mix; |
          %dict.mix;)*&gt;</eg>
        </div3>
        <div3 id="sec-mixed-content">
          <head>Mixed Content</head>
          <p>
          <termdef id="dt-mixed" term="Mixed Content">An element 
          <termref def="dt-stag">type</termref>has 
          <term>mixed content</term>when elements of that type may
          contain character data, optionally interspersed with 
          <termref def="dt-parentchild">
          child</termref>elements.</termdef>In this case, the types
          of the child elements may be constrained, but not their
          order or their number of occurrences:</p>
          <scrap lang="ebnf">
            <head>Mixed-content Declaration</head>
            <prodgroup pcw2="5.5" pcw4="16" pcw5="11">
              <prod id="NT-Mixed" num="51">
                <lhs>Mixed</lhs>
                <rhs>'(' 
                <nt def="NT-S">S</nt>? '#PCDATA' (
                <nt def="NT-S">S</nt>? '|' 
                <nt def="NT-S">S</nt>? 
                <nt def="NT-Name">Name</nt>)* 
                <nt def="NT-S">S</nt>? ')*'</rhs>
                <rhs>| '(' 
                <nt def="NT-S">S</nt>? '#PCDATA' 
                <nt def="NT-S">S</nt>? ')'</rhs>
                <vc def="vc-PEinGroup" />
                <vc def="vc-MixedChildrenUnique" />
              </prod>
            </prodgroup>
          </scrap>
          <p>where the 
          <nt def="NT-Name">Name</nt>s give the types of elements
          that may appear as children. The keyword 
          <kw>#PCDATA</kw>derives historically from the term 
          <quote>parsed character data.</quote></p>
          <vcnote id="vc-MixedChildrenUnique">
            <head>No Duplicate Types</head>
            <p>The same name 
            <rfc2119>MUST NOT</rfc2119>appear more than once in a
            single mixed-content declaration.</p>
          </vcnote>
          <p>Examples of mixed content declarations:</p>
          <eg>&lt;!ELEMENT p (#PCDATA|a|ul|b|i|em)*&gt;
          &lt;!ELEMENT p (#PCDATA | %font; | %phrase; | %special; |
          %form;)* &gt; &lt;!ELEMENT b (#PCDATA)&gt;</eg>
        </div3>
      </div2>
      <div2 id="attdecls">
        <head>Attribute-List Declarations</head>
        <p>
        <termref def="dt-attr">Attributes</termref>are used to
        associate name-value pairs with 
        <termref def="dt-element">elements</termref>. Attribute
        specifications 
        <rfc2119>MUST NOT</rfc2119>appear outside of 
        <termref def="dt-stag">start-tags</termref>and 
        <termref def="dt-eetag">empty-element tags</termref>; thus,
        the productions used to recognize them appear in 
        <specref ref="sec-starttags" />. Attribute-list
        declarations may be used:</p>
        <ulist>
          <item>
            <p>To define the set of attributes pertaining to a
            given element type.</p>
          </item>
          <item>
            <p>To establish type constraints for these
            attributes.</p>
          </item>
          <item>
            <p>To provide 
            <termref def="dt-default">default values</termref>for
            attributes.</p>
          </item>
        </ulist>
        <p>
          <termdef id="dt-attdecl"
          term="Attribute-List Declaration">
          <term>Attribute-list declarations</term>specify the name,
          data type, and default value (if any) of each attribute
          associated with a given element type:</termdef>
        </p>
        <scrap lang="ebnf">
          <head>Attribute-list Declaration</head>
          <prod id="NT-AttlistDecl" num="52">
            <lhs>AttlistDecl</lhs>
            <rhs>'&lt;!ATTLIST' 
            <nt def="NT-S">S</nt>
            <nt def="NT-Name">Name</nt>
            <nt def="NT-AttDef">AttDef</nt>* 
            <nt def="NT-S">S</nt>? '&gt;'</rhs>
          </prod>
          <prod id="NT-AttDef" num="53">
            <lhs>AttDef</lhs>
            <rhs>
              <nt def="NT-S">S</nt>
              <nt def="NT-Name">Name</nt>
              <nt def="NT-S">S</nt>
              <nt def="NT-AttType">AttType</nt>
              <nt def="NT-S">S</nt>
              <nt def="NT-DefaultDecl">DefaultDecl</nt>
            </rhs>
          </prod>
        </scrap>
        <p>The 
        <nt def="NT-Name">Name</nt>in the 
        <nt def="NT-AttlistDecl">AttlistDecl</nt>rule is the type
        of an element. At user option, an XML processor 
        <rfc2119>MAY</rfc2119>issue a warning if attributes are
        declared for an element type not itself declared, but this
        is not an error. The 
        <nt def="NT-Name">Name</nt>in the 
        <nt def="NT-AttDef">AttDef</nt>rule is the name of the
        attribute.</p>
        <p>When more than one 
        <nt def="NT-AttlistDecl">AttlistDecl</nt>is provided for a
        given element type, the contents of all those provided are
        merged. When more than one definition is provided for the
        same attribute of a given element type, the first
        declaration is binding and later declarations are ignored. 
        <termref def="dt-interop">For
        interoperability,</termref>writers of DTDs may choose to
        provide at most one attribute-list declaration for a given
        element type, at most one attribute definition for a given
        attribute name in an attribute-list declaration, and at
        least one attribute definition in each attribute-list
        declaration. For interoperability, an XML processor 
        <rfc2119>MAY</rfc2119>at user option issue a warning when
        more than one attribute-list declaration is provided for a
        given element type, or more than one attribute definition
        is provided for a given attribute, but this is not an
        error.</p>
        <div3 id="sec-attribute-types">
          <head>Attribute Types</head>
          <p>XML attribute types are of three kinds: a string type,
          a set of tokenized types, and enumerated types. The
          string type may take any literal string as a value; the
          tokenized types are more constrained. The validity
          constraints noted in the grammar are applied after the
          attribute value has been normalized as described in 
          <specref ref="AVNormalize" />.</p>
          <scrap lang="ebnf">
            <head>Attribute Types</head>
            <prodgroup pcw4="14" pcw5="11.5">
              <prod id="NT-AttType" num="54">
                <lhs>AttType</lhs>
                <rhs>
                <nt def="NT-StringType">StringType</nt>| 
                <nt def="NT-TokenizedType">TokenizedType</nt>| 
                <nt def="NT-EnumeratedType">
                EnumeratedType</nt></rhs>
              </prod>
              <prod id="NT-StringType" num="55">
                <lhs>StringType</lhs>
                <rhs>'CDATA'</rhs>
              </prod>
              <prod id="NT-TokenizedType" num="56">
                <lhs>TokenizedType</lhs>
                <rhs>'ID'</rhs>
                <vc def="id" />
                <vc def="one-id-per-el" />
                <vc def="id-default" />
                <rhs>| 'IDREF'</rhs>
                <vc def="idref" />
                <rhs>| 'IDREFS'</rhs>
                <vc def="idref" />
                <rhs>| 'ENTITY'</rhs>
                <vc def="entname" />
                <rhs>| 'ENTITIES'</rhs>
                <vc def="entname" />
                <rhs>| 'NMTOKEN'</rhs>
                <vc def="nmtok" />
                <rhs>| 'NMTOKENS'</rhs>
                <vc def="nmtok" />
              </prod>
            </prodgroup>
          </scrap>
          <vcnote id="id">
            <head>ID</head>
            <p>Values of type 
            <kw>ID</kw>
            <rfc2119>MUST</rfc2119>match the 
            <nt def="NT-Name">Name</nt>production. A name 
            <rfc2119>MUST NOT</rfc2119>appear more than once in an
            XML document as a value of this type; i.e., ID values 
            <rfc2119>MUST</rfc2119>uniquely identify the elements
            which bear them.</p>
          </vcnote>
          <vcnote id="one-id-per-el">
            <head>One ID per Element Type</head>
            <p>An element type 
            <rfc2119>MUST NOT</rfc2119>have more than one ID
            attribute specified.</p>
          </vcnote>
          <vcnote id="id-default">
            <head>ID Attribute Default</head>
            <p>An ID attribute 
            <rfc2119>MUST</rfc2119>have a declared default of 
            <kw>#IMPLIED</kw>or 
            <kw>#REQUIRED</kw>.</p>
          </vcnote>
          <vcnote id="idref">
            <head>IDREF</head>
            <p>Values of type 
            <kw>IDREF</kw>
            <rfc2119>MUST</rfc2119>match the 
            <nt def="NT-Name">Name</nt>production, and values of
            type 
            <kw>IDREFS</kw>
            <rfc2119>MUST</rfc2119>match 
            <nt def="NT-Names">Names</nt>; each 
            <nt def="NT-Name">Name</nt>
            <rfc2119>MUST</rfc2119>match the value of an ID
            attribute on some element in the XML document; i.e. 
            <kw>IDREF</kw>values 
            <rfc2119>MUST</rfc2119>match the value of some ID
            attribute.</p>
          </vcnote>
          <vcnote id="entname">
            <head>Entity Name</head>
            <p>Values of type 
            <kw>ENTITY</kw>
            <rfc2119>MUST</rfc2119>match the 
            <nt def="NT-Name">Name</nt>production, values of type 
            <kw>ENTITIES</kw>
            <rfc2119>MUST</rfc2119>match 
            <nt def="NT-Names">Names</nt>; each 
            <nt def="NT-Name">Name</nt>
            <rfc2119>MUST</rfc2119>match the name of an 
            <termref def="dt-unparsed">unparsed
            entity</termref>declared in the 
            <termref def="dt-doctype">DTD</termref>.</p>
          </vcnote>
          <vcnote id="nmtok">
            <head>Name Token</head>
            <p>Values of type 
            <kw>NMTOKEN</kw>
            <rfc2119>MUST</rfc2119>match the 
            <nt def="NT-Nmtoken">Nmtoken</nt>production; values of
            type 
            <kw>NMTOKENS</kw>
            <rfc2119>MUST</rfc2119>match 
            <nt def="NT-Nmtokens">Nmtokens</nt>.</p>
          </vcnote>
          <p>
          <termdef id="dt-enumerated"
          term="Enumerated Attribute Values">
          <term>Enumerated attributes</term>have a list of allowed
          values in their declaration</termdef>. They 
          <rfc2119>MUST</rfc2119>take one of those values. There
          are two kinds of enumerated attribute types:</p>
          <scrap lang="ebnf">
            <head>Enumerated Attribute Types</head>
            <prod id="NT-EnumeratedType" num="57">
              <lhs>EnumeratedType</lhs>
              <rhs>
              <nt def="NT-NotationType">NotationType</nt>| 
              <nt def="NT-Enumeration">Enumeration</nt></rhs>
            </prod>
            <prod id="NT-NotationType" num="58">
              <lhs>NotationType</lhs>
              <rhs>'NOTATION' 
              <nt def="NT-S">S</nt>'(' 
              <nt def="NT-S">S</nt>? 
              <nt def="NT-Name">Name</nt>(
              <nt def="NT-S">S</nt>? '|' 
              <nt def="NT-S">S</nt>? 
              <nt def="NT-Name">Name</nt>)* 
              <nt def="NT-S">S</nt>? ')'</rhs>
              <vc def="notatn" />
              <vc def="OneNotationPer" />
              <vc def="NoNotationEmpty" />
              <vc def="NoDuplicateTokens" />
            </prod>
            <prod id="NT-Enumeration" num="59">
              <lhs>Enumeration</lhs>
              <rhs>'(' 
              <nt def="NT-S">S</nt>? 
              <nt def="NT-Nmtoken">Nmtoken</nt>(
              <nt def="NT-S">S</nt>? '|' 
              <nt def="NT-S">S</nt>? 
              <nt def="NT-Nmtoken">Nmtoken</nt>)* 
              <nt def="NT-S">S</nt>? ')'</rhs>
              <vc def="enum" />
              <vc def="NoDuplicateTokens" />
            </prod>
          </scrap>
          <p>A 
          <kw>NOTATION</kw>attribute identifies a 
          <termref def="dt-notation">notation</termref>, declared
          in the DTD with associated system and/or public
          identifiers, to be used in interpreting the element to
          which the attribute is attached.</p>
          <vcnote id="notatn">
            <head>Notation Attributes</head>
            <p>Values of this type 
            <rfc2119>MUST</rfc2119>match one of the 
            <titleref href="#Notations">notation</titleref>names
            included in the declaration; all notation names in the
            declaration 
            <rfc2119>MUST</rfc2119>be declared.</p>
          </vcnote>
          <vcnote id="OneNotationPer">
            <head>One Notation Per Element Type</head>
            <p>An element type 
            <rfc2119>MUST NOT</rfc2119>have more than one 
            <kw>NOTATION</kw>attribute specified.</p>
          </vcnote>
          <vcnote id="NoNotationEmpty">
            <head>No Notation on Empty Element</head>
            <p>
            <termref def="dt-compat">For compatibility</termref>,
            an attribute of type 
            <kw>NOTATION</kw>
            <rfc2119>MUST NOT</rfc2119>be declared on an element
            declared 
            <kw>EMPTY</kw>.</p>
          </vcnote>
          <vcnote id="NoDuplicateTokens">
            <head>No Duplicate Tokens</head>
            <p>The notation names in a single 
            <nt def="NT-NotationType">NotationType</nt>attribute
            declaration, as well as the 
            <nt def="NT-Nmtoken">NmToken</nt>s in a single 
            <nt def="NT-Enumeration">Enumeration</nt>attribute
            declaration, 
            <rfc2119>MUST</rfc2119>all be distinct.</p>
          </vcnote>
          <vcnote id="enum">
            <head>Enumeration</head>
            <p>Values of this type 
            <rfc2119>MUST</rfc2119>match one of the 
            <nt def="NT-Nmtoken">Nmtoken</nt>tokens in the
            declaration.</p>
          </vcnote>
          <p>
          <termref def="dt-interop">For
          interoperability,</termref>the same 
          <nt def="NT-Nmtoken">Nmtoken</nt>
          <rfc2119>SHOULD NOT</rfc2119>occur more than once in the
          enumerated attribute types of a single element type.</p>
        </div3>
        <div3 id="sec-attr-defaults">
          <head>Attribute Defaults</head>
          <p>An 
          <termref def="dt-attdecl">attribute
          declaration</termref>provides information on whether the
          attribute's presence is 
          <rfc2119>REQUIRED</rfc2119>, and if not, how an XML
          processor is to react if a declared attribute is absent
          in a document.</p>
          <scrap lang="ebnf">
            <head>Attribute Defaults</head>
            <prodgroup pcw4="14" pcw5="11.5">
              <prod id="NT-DefaultDecl" num="60">
                <lhs>DefaultDecl</lhs>
                <rhs>'#REQUIRED' |&#194;&#160;'#IMPLIED'</rhs>
                <rhs>| (('#FIXED' 
                <nt def="NT-S">S</nt>)? 
                <nt def="NT-AttValue">AttValue</nt>)</rhs>
                <vc def="RequiredAttr" />
                <vc def="defattrvalid" />
                <wfc def="CleanAttrVals" />
                <vc def="FixedAttr" />
                <wfc def="NoExternalRefs" />
              </prod>
            </prodgroup>
          </scrap>
          <p>In an attribute declaration, 
          <kw>#REQUIRED</kw>means that the attribute 
          <rfc2119>MUST</rfc2119>always be provided, 
          <kw>#IMPLIED</kw>that no default value is provided. 
          <termdef id="dt-default" term="Attribute Default">If the
          declaration is neither 
          <kw>#REQUIRED</kw>nor 
          <kw>#IMPLIED</kw>, then the 
          <nt def="NT-AttValue">AttValue</nt>value contains the
          declared 
          <term>default</term>value; the 
          <kw>#FIXED</kw>keyword states that the attribute 
          <rfc2119>MUST</rfc2119>always have the default value.
          When an XML processor encounters an element without a
          specification for an attribute for which it has read a
          default value declaration, it 
          <rfc2119>MUST</rfc2119>report the attribute with the
          declared default value to the application.</termdef></p>
          <vcnote id="RequiredAttr">
            <head>Required Attribute</head>
            <p>If the default declaration is the keyword 
            <kw>#REQUIRED</kw>, then the attribute 
            <rfc2119>MUST</rfc2119>be specified for all elements of
            the type in the attribute-list declaration.</p>
          </vcnote>
          <vcnote id="defattrvalid">
            <head>Attribute Default Value Syntactically
            Correct</head>
            <p>The declared default value 
            <rfc2119>MUST</rfc2119>meet the syntactic constraints
            of the declared attribute type. That is, the default
            value of an attribute:</p>
            <ulist>
              <item>
                <p>of type IDREF or ENTITY must match the 
                <nt def="NT-Name">Name</nt>production;</p>
              </item>
              <item>
                <p>of type IDREFS or ENTITIES must match the 
                <nt def="NT-Names">Names</nt>production;</p>
              </item>
              <item>
                <p>of type NMTOKEN must match the 
                <nt def="NT-Nmtoken">Nmtoken</nt>production;</p>
              </item>
              <item>
                <p>of type NMTOKENS must match the 
                <nt def="NT-Nmtokens">Nmtokens</nt>production;</p>
              </item>
              <item>
                <p>of an 
                <nt def="NT-EnumeratedType">enumerated
                type</nt>(either a 
                <nt def="NT-NotationType">NOTATION</nt>type or an 
                <nt def="NT-Enumeration">enumeration</nt>) must
                match one of the enumerated values.</p>
              </item>
            </ulist>
            <p>Note that only the syntactic constraints of the type
            are required here; other constraints (e.g. that the
            value be the name of a declared unparsed entity, for an
            attribute of type ENTITY) will be reported by a
            validating parser only if an element without a
            specification for this attribute actually occurs.</p>
          </vcnote>
          <vcnote id="FixedAttr">
            <head>Fixed Attribute Default</head>
            <p>If an attribute has a default value declared with
            the 
            <kw>#FIXED</kw>keyword, instances of that attribute 
            <rfc2119>MUST</rfc2119>match the default value.</p>
          </vcnote>
          <p>Examples of attribute-list declarations:</p>
          <eg>&lt;!ATTLIST termdef id ID #REQUIRED name CDATA
          #IMPLIED&gt; &lt;!ATTLIST list type
          (bullets|ordered|glossary) "ordered"&gt; &lt;!ATTLIST
          form method CDATA #FIXED "POST"&gt;</eg>
        </div3>
        <div3 id="AVNormalize">
          <head>Attribute-Value Normalization</head>
          <p>Before the value of an attribute is passed to the
          application or checked for validity, the XML processor 
          <rfc2119>MUST</rfc2119>normalize the attribute value by
          applying the algorithm below, or by using some other
          method such that the value passed to the application is
          the same as that produced by the algorithm.</p>
          <olist>
            <item>
              <p>All line breaks 
              <rfc2119>MUST</rfc2119>have been normalized on input
              to #xA as described in 
              <specref ref="sec-line-ends" />, so the rest of this
              algorithm operates on text normalized in this
              way.</p>
            </item>
            <item>
              <p>Begin with a normalized value consisting of the
              empty string.</p>
            </item>
            <item>
              <p>For each character, entity reference, or character
              reference in the unnormalized attribute value,
              beginning with the first and continuing to the last,
              do the following:</p>
              <ulist>
                <item>
                  <p>For a character reference, append the
                  referenced character to the normalized value.</p>
                </item>
                <item>
                  <p>For an entity reference, recursively apply
                  step 3 of this algorithm to the replacement text
                  of the entity.</p>
                </item>
                <item>
                  <p>For a white space character (#x20, #xD, #xA,
                  #x9), append a space character (#x20) to the
                  normalized value.</p>
                </item>
                <item>
                  <p>For another character, append the character to
                  the normalized value.</p>
                </item>
              </ulist>
            </item>
          </olist>
          <p>If the attribute type is not CDATA, then the XML
          processor 
          <rfc2119>MUST</rfc2119>further process the normalized
          attribute value by discarding any leading and trailing
          space (#x20) characters, and by replacing sequences of
          space (#x20) characters by a single space (#x20)
          character.</p>
          <p>Note that if the unnormalized attribute value contains
          a character reference to a white space character other
          than space (#x20), the normalized value contains the
          referenced character itself (#xD, #xA or #x9). This
          contrasts with the case where the unnormalized value
          contains a white space character (not a reference), which
          is replaced with a space character (#x20) in the
          normalized value and also contrasts with the case where
          the unnormalized value contains an entity reference whose
          replacement text contains a white space character; being
          recursively processed, the white space character is
          replaced with a space character (#x20) in the normalized
          value.</p>
          <p>All attributes for which no declaration has been read 
          <rfc2119>SHOULD</rfc2119>be treated by a non-validating
          processor as if declared 
          <kw>CDATA</kw>.</p>
          <p>It is an error if an 
          <termref def="dt-attrval">attribute
          value</termref>contains a 
          <termref def="dt-entref">reference</termref>to an entity
          for which no declaration has been read.</p>
          <p>Following are examples of attribute normalization.
          Given the following declarations:</p>
          <eg>&lt;!ENTITY d "&amp;#xD;"&gt; &lt;!ENTITY a
          "&amp;#xA;"&gt; &lt;!ENTITY da
          "&amp;#xD;&amp;#xA;"&gt;</eg>
          <p>the attribute specifications in the left column below
          would be normalized to the character sequences of the
          middle column if the attribute 
          <att>a</att>is declared 
          <kw>NMTOKENS</kw>and to those of the right columns if 
          <att>a</att>is declared 
          <kw>CDATA</kw>.</p>
          <table border="1" frame="border">
            <thead>
              <tr>
                <th>Attribute specification</th>
                <th>a is NMTOKENS</th>
                <th>a is CDATA</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>
                  <eg>a=" xyz"</eg>
                </td>
                <td>
                  <eg>x y z</eg>
                </td>
                <td>
                  <eg>#x20 #x20 x y z</eg>
                </td>
              </tr>
              <tr>
                <td>
                  <eg>
                  a="&amp;d;&amp;d;A&amp;a;&amp;#x20;&amp;a;B&amp;da;"</eg>
                </td>
                <td>
                  <eg>A #x20 B</eg>
                </td>
                <td>
                  <eg>#x20 #x20 A #x20 #x20 #x20 B #x20 #x20</eg>
                </td>
              </tr>
              <tr>
                <td>
                  <eg>a=
                  "&amp;#xd;&amp;#xd;A&amp;#xa;&amp;#xa;B&amp;#xd;&amp;#xa;"</eg>
                </td>
                <td>
                  <eg>#xD #xD A #xA #xA B #xD #xA</eg>
                </td>
                <td>
                  <eg>#xD #xD A #xA #xA B #xD #xA</eg>
                </td>
              </tr>
            </tbody>
          </table>
          <p>Note that the last example is invalid (but
          well-formed) if 
          <att>a</att>is declared to be of type 
          <kw>NMTOKENS</kw>.</p>
        </div3>
      </div2>
      <div2 id="sec-condition-sect">
        <head>Conditional Sections</head>
        <p>
          <termdef id="dt-cond-section" term="conditional section">
          <term>Conditional sections</term>are portions of the 
          <termref def="dt-doctype">document type declaration
          external subset</termref>or of external parameter
          entities which are included in, or excluded from, the
          logical structure of the DTD based on the keyword which
          governs them.</termdef>
        </p>
        <scrap lang="ebnf">
          <head>Conditional Section</head>
          <prodgroup pcw2="9" pcw4="14.5">
            <prod id="NT-conditionalSect" num="61">
              <lhs>conditionalSect</lhs>
              <rhs>
              <nt def="NT-includeSect">includeSect</nt>| 
              <nt def="NT-ignoreSect">ignoreSect</nt></rhs>
            </prod>
            <prod id="NT-includeSect" num="62">
              <lhs>includeSect</lhs>
              <rhs>'&lt;![' 
              <nt def="NT-S">S</nt>? 'INCLUDE' 
              <nt def="NT-S">S</nt>? '[' 
              <nt def="NT-extSubsetDecl">
              extSubsetDecl</nt>']]&gt;'</rhs>
              <vc def="condsec-nesting" />
            </prod>
            <prod id="NT-ignoreSect" num="63">
              <lhs>ignoreSect</lhs>
              <rhs>'&lt;![' 
              <nt def="NT-S">S</nt>? 'IGNORE' 
              <nt def="NT-S">S</nt>? '[' 
              <nt def="NT-ignoreSectContents">
              ignoreSectContents</nt>* ']]&gt;'</rhs>
              <vc def="condsec-nesting" />
            </prod>
            <prod id="NT-ignoreSectContents" num="64">
              <lhs>ignoreSectContents</lhs>
              <rhs>
              <nt def="NT-Ignore">Ignore</nt>('&lt;![' 
              <nt def="NT-ignoreSectContents">
              ignoreSectContents</nt>']]&gt;' 
              <nt def="NT-Ignore">Ignore</nt>)*</rhs>
            </prod>
            <prod id="NT-Ignore" num="65">
              <lhs>Ignore</lhs>
              <rhs>
              <nt def="NT-Char">Char</nt>* - (
              <nt def="NT-Char">Char</nt>* ('&lt;![' | ']]&gt;') 
              <nt def="NT-Char">Char</nt>*)</rhs>
            </prod>
          </prodgroup>
        </scrap>
        <vcnote id="condsec-nesting">
          <head>Proper Conditional Section/PE Nesting</head>
          <p>If any of the "
          <code>&lt;![</code>", "
          <code>[</code>", or "
          <code>]]&gt;</code>" of a conditional section is
          contained in the replacement text for a parameter-entity
          reference, all of them 
          <rfc2119>MUST</rfc2119>be contained in the same
          replacement text.</p>
        </vcnote>
        <p>Like the internal and external DTD subsets, a
        conditional section may contain one or more complete
        declarations, comments, processing instructions, or nested
        conditional sections, intermingled with white space.</p>
        <p>If the keyword of the conditional section is 
        <kw>INCLUDE</kw>, then the contents of the conditional
        section 
        <rfc2119>MUST</rfc2119>be processed as part of the DTD. If
        the keyword of the conditional section is 
        <kw>IGNORE</kw>, then the contents of the conditional
        section 
        <rfc2119>MUST</rfc2119>
        <rfc2119>NOT</rfc2119>be processed as part of the DTD. If a
        conditional section with a keyword of 
        <kw>INCLUDE</kw>occurs within a larger conditional section
        with a keyword of 
        <kw>IGNORE</kw>, both the outer and the inner conditional
        sections 
        <rfc2119>MUST</rfc2119>be ignored. The contents of an
        ignored conditional section 
        <rfc2119>MUST</rfc2119>be parsed by ignoring all characters
        after the "
        <code>[</code>" following the keyword, except conditional
        section starts "
        <code>&lt;![</code>" and ends "
        <code>]]&gt;</code>", until the matching conditional
        section end is found. Parameter entity references 
        <rfc2119>MUST NOT</rfc2119>be recognized in this
        process.</p>
        <p>If the keyword of the conditional section is a
        parameter-entity reference, the parameter entity 
        <rfc2119>MUST</rfc2119>be replaced by its content before
        the processor decides whether to include or ignore the
        conditional section.</p>
        <p>An example:</p>
        <eg>&lt;!ENTITY % draft 'INCLUDE' &gt; &lt;!ENTITY % final
        'IGNORE' &gt; &lt;![%draft;[ &lt;!ELEMENT book (comments*,
        title, body, supplements?)&gt; ]]&gt; &lt;![%final;[
        &lt;!ELEMENT book (title, body, supplements?)&gt;
        ]]&gt;</eg>
      </div2>
    </div1>
    <div1 id="sec-physical-struct">
      <head>Physical Structures</head>
      <p>
      <termdef id="dt-entity" term="Entity">An XML document may
      consist of one or many storage units. These are called 
      <term>entities</term>; they all have 
      <term>content</term>and are all (except for the 
      <termref def="dt-docent">document entity</termref>and the 
      <termref def="dt-doctype">external DTD subset</termref>)
      identified by entity 
      <term>name</term>.</termdef>Each XML document has one entity
      called the 
      <termref def="dt-docent">document entity</termref>, which
      serves as the starting point for the 
      <termref def="dt-xml-proc">XML processor</termref>and may
      contain the whole document.</p>
      <p>Entities may be either parsed or unparsed. 
      <termdef id="dt-parsedent" term="Text Entity">The contents of
      a 
      <term>parsed entity</term>are referred to as its 
      <termref def="dt-repltext">replacement text</termref>; this 
      <termref def="dt-text">text</termref>is considered an
      integral part of the document.</termdef></p>
      <p>
        <termdef id="dt-unparsed" term="Unparsed Entity">An 
        <term>unparsed entity</term>is a resource whose contents
        may or may not be 
        <termref def="dt-text">text</termref>, and if text, may be
        other than XML. Each unparsed entity has an associated 
        <termref def="dt-notation">notation</termref>, identified
        by name. Beyond a requirement that an XML processor make
        the identifiers for the entity and notation available to
        the application, XML places no constraints on the contents
        of unparsed entities.</termdef>
      </p>
      <p>Parsed entities are invoked by name using entity
      references; unparsed entities by name, given in the value of 
      <kw>ENTITY</kw>or 
      <kw>ENTITIES</kw>attributes.</p>
      <p>
      <termdef id="gen-entity" term="general entity">
      <term>General entities</term>are entities for use within the
      document content. In this specification, general entities are
      sometimes referred to with the unqualified term 
      <emph>entity</emph>when this leads to no ambiguity.</termdef>
      <termdef id="dt-PE" term="Parameter entity">
      <term>Parameter entities</term>are parsed entities for use
      within the DTD.</termdef>These two types of entities use
      different forms of reference and are recognized in different
      contexts. Furthermore, they occupy different namespaces; a
      parameter entity and a general entity with the same name are
      two distinct entities.</p>
      <div2 id="sec-references">
        <head>Character and Entity References</head>
        <p>
          <termdef id="dt-charref" term="Character Reference">A 
          <term>character reference</term>refers to a specific
          character in the ISO/IEC 10646 character set, for example
          one not directly accessible from available input
          devices.</termdef>
        </p>
        <scrap lang="ebnf">
          <head>Character Reference</head>
          <prod id="NT-CharRef" num="66">
            <lhs>CharRef</lhs>
            <rhs>'&amp;#' [0-9]+ ';'</rhs>
            <rhs>| '&amp;#x' [0-9a-fA-F]+ ';'</rhs>
            <wfc def="wf-Legalchar" />
          </prod>
        </scrap>
        <wfcnote id="wf-Legalchar">
          <head>Legal Character</head>
          <p>Characters referred to using character references 
          <rfc2119>MUST</rfc2119>match the production for 
          <nt def="NT-Char">Char</nt>.</p>
        </wfcnote>
        <p>If the character reference begins with 
        <quote>
          <code>&amp;#x</code>
        </quote>, the digits and letters up to the terminating 
        <code>;</code>provide a hexadecimal representation of the
        character's code point in ISO/IEC 10646. If it begins just
        with 
        <quote>
          <code>&amp;#</code>
        </quote>, the digits up to the terminating 
        <code>;</code>provide a decimal representation of the
        character's code point.</p>
        <p>
          <termdef id="dt-entref" term="Entity Reference">An 
          <term>entity reference</term>refers to the content of a
          named entity.</termdef>
          <termdef id="dt-GERef" term="General Entity Reference">
          References to parsed general entities use ampersand (
          <code>&amp;</code>) and semicolon (
          <code>;</code>) as delimiters.</termdef>
          <termdef id="dt-PERef" term="Parameter-entity reference">
          <term>Parameter-entity references</term>use percent-sign
          (
          <code>%</code>) and semicolon (
          <code>;</code>) as delimiters.</termdef>
        </p>
        <scrap lang="ebnf">
          <head>Entity Reference</head>
          <prod id="NT-Reference" num="67">
            <lhs>Reference</lhs>
            <rhs>
            <nt def="NT-EntityRef">EntityRef</nt>| 
            <nt def="NT-CharRef">CharRef</nt></rhs>
          </prod>
          <prod id="NT-EntityRef" num="68">
            <lhs>EntityRef</lhs>
            <rhs>'&amp;' 
            <nt def="NT-Name">Name</nt>';'</rhs>
            <wfc def="wf-entdeclared" />
            <vc def="vc-entdeclared" />
            <wfc def="textent" />
            <wfc def="norecursion" />
          </prod>
          <prod id="NT-PEReference" num="69">
            <lhs>PEReference</lhs>
            <rhs>'%' 
            <nt def="NT-Name">Name</nt>';'</rhs>
            <vc def="vc-entdeclared" />
            <wfc def="norecursion" />
            <wfc def="indtd" />
          </prod>
        </scrap>
        <wfcnote id="wf-entdeclared">
          <head>Entity Declared</head>
          <p>In a document without any DTD, a document with only an
          internal DTD subset which contains no parameter entity
          references, or a document with 
          <quote>
            <code>standalone='yes'</code>
          </quote>, for an entity reference that does not occur
          within the external subset or a parameter entity, the 
          <nt def="NT-Name">Name</nt>given in the entity reference 
          <rfc2119>MUST</rfc2119>
          <termref def="dt-match">match</termref>that in an 
          <titleref href="#sec-entity-decl">entity
          declaration</titleref>that does not occur within the
          external subset or a parameter entity, except that
          well-formed documents need not declare any of the
          following entities: 
          <code>amp</code>, 
          <code>lt</code>, 
          <code>gt</code>, 
          <code>apos</code>, 
          <code>quot</code>. The declaration of a general entity 
          <rfc2119>MUST</rfc2119>precede any reference to it which
          appears in a default value in an attribute-list
          declaration.</p>
          <p>Note that non-validating processors are 
          <titleref href="#include-if-valid">not obligated
          to</titleref>
          <phrase diff="del">
          <loc role="erratumref" href="E03" />to</phrase>read and
          process entity declarations occurring in parameter
          entities or in the external subset; for such documents,
          the rule that an entity must be declared is a
          well-formedness constraint only if 
          <titleref href="#sec-rmd">
          standalone='yes'</titleref>.</p>
        </wfcnote>
        <vcnote id="vc-entdeclared">
          <head>Entity Declared</head>
          <p>In a document with an external subset or parameter
          entity references
          <phrase diff="chg">
          <loc role="erratumref" href="E08" />, if the document is
          not standalone (either 
          <quote>
            <code>standalone='no'</code>
          </quote>is specified or there is no standalone
          declaration), then</phrase>the 
          <nt def="NT-Name">Name</nt>given in the entity reference 
          <rfc2119>MUST</rfc2119>
          <termref def="dt-match">match</termref>that in an 
          <titleref href="#sec-entity-decl">entity
          declaration</titleref>. For interoperability, valid
          documents 
          <rfc2119>SHOULD</rfc2119>declare the entities 
          <code>amp</code>, 
          <code>lt</code>, 
          <code>gt</code>, 
          <code>apos</code>, 
          <code>quot</code>, in the form specified in 
          <specref ref="sec-predefined-ent" />. The declaration of
          a parameter entity 
          <rfc2119>MUST</rfc2119>precede any reference to it.
          Similarly, the declaration of a general entity 
          <rfc2119>MUST</rfc2119>precede any attribute-list
          declaration containing a default value with a direct or
          indirect reference to that general entity.</p>
        </vcnote>
        <wfcnote id="textent">
          <head>Parsed Entity</head>
          <p>An entity reference 
          <rfc2119>MUST NOT</rfc2119>contain the name of an 
          <termref def="dt-unparsed">unparsed entity</termref>.
          Unparsed entities may be referred to only in 
          <termref def="dt-attrval">attribute
          values</termref>declared to be of type 
          <kw>ENTITY</kw>or 
          <kw>ENTITIES</kw>.</p>
        </wfcnote>
        <wfcnote id="norecursion">
          <head>No Recursion</head>
          <p>A parsed entity 
          <rfc2119>MUST NOT</rfc2119>contain a recursive reference
          to itself, either directly or indirectly.</p>
        </wfcnote>
        <wfcnote id="indtd">
          <head>In DTD</head>
          <p>Parameter-entity references 
          <rfc2119>MUST NOT</rfc2119>appear outside the 
          <termref def="dt-doctype">DTD</termref>.</p>
        </wfcnote>
        <p>Examples of character and entity references:</p>
        <eg>Type &lt;key&gt;less-than&lt;/key&gt; (&amp;#x3C;) to
        save options. This document was prepared on &amp;docdate;
        and is classified &amp;security-level;.</eg>
        <p>Example of a parameter-entity reference:</p>
        <eg>&lt;!-- declare the parameter entity "ISOLat2"...
        --&gt; &lt;!ENTITY % ISOLat2 SYSTEM
        "http://www.xml.com/iso/isolat2-xml.entities" &gt; &lt;!--
        ... now reference it. --&gt; %ISOLat2;</eg>
      </div2>
      <div2 id="sec-entity-decl">
        <head>Entity Declarations</head>
        <p>
          <termdef id="dt-entdecl" term="entity declaration">
          Entities are declared thus:</termdef>
        </p>
        <scrap lang="ebnf">
          <head>Entity Declaration</head>
          <prodgroup pcw2="5" pcw4="18.5">
            <prod id="NT-EntityDecl" num="70">
              <lhs>EntityDecl</lhs>
              <rhs>
              <nt def="NT-GEDecl">GEDecl</nt>| 
              <nt def="NT-PEDecl">PEDecl</nt></rhs>
            </prod>
            <prod id="NT-GEDecl" num="71">
              <lhs>GEDecl</lhs>
              <rhs>'&lt;!ENTITY' 
              <nt def="NT-S">S</nt>
              <nt def="NT-Name">Name</nt>
              <nt def="NT-S">S</nt>
              <nt def="NT-EntityDef">EntityDef</nt>
              <nt def="NT-S">S</nt>? '&gt;'</rhs>
            </prod>
            <prod id="NT-PEDecl" num="72">
              <lhs>PEDecl</lhs>
              <rhs>'&lt;!ENTITY' 
              <nt def="NT-S">S</nt>'%' 
              <nt def="NT-S">S</nt>
              <nt def="NT-Name">Name</nt>
              <nt def="NT-S">S</nt>
              <nt def="NT-PEDef">PEDef</nt>
              <nt def="NT-S">S</nt>? '&gt;'</rhs>
            </prod>
            <prod id="NT-EntityDef" num="73">
              <lhs>EntityDef</lhs>
              <rhs>
              <nt def="NT-EntityValue">EntityValue</nt>| (
              <nt def="NT-ExternalID">ExternalID</nt>
              <nt def="NT-NDataDecl">NDataDecl</nt>?)</rhs>
            </prod>
            <prod id="NT-PEDef" num="74">
              <lhs>PEDef</lhs>
              <rhs>
              <nt def="NT-EntityValue">EntityValue</nt>| 
              <nt def="NT-ExternalID">ExternalID</nt></rhs>
            </prod>
          </prodgroup>
        </scrap>
        <p>The 
        <nt def="NT-Name">Name</nt>identifies the entity in an 
        <termref def="dt-entref">entity reference</termref>or, in
        the case of an unparsed entity, in the value of an 
        <kw>ENTITY</kw>or 
        <kw>ENTITIES</kw>attribute. If the same entity is declared
        more than once, the first declaration encountered is
        binding; at user option, an XML processor 
        <rfc2119>MAY</rfc2119>issue a warning if entities are
        declared multiple times.</p>
        <div3 id="sec-internal-ent">
          <head>Internal Entities</head>
          <p>
          <termdef id="dt-internent"
          term="Internal Entity Replacement Text">If the entity
          definition is an 
          <nt def="NT-EntityValue">EntityValue</nt>, the defined
          entity is called an 
          <term>internal entity</term>. There is no separate
          physical storage object, and the content of the entity is
          given in the declaration.</termdef>Note that some
          processing of entity and character references in the 
          <termref def="dt-litentval">literal entity
          value</termref>may be required to produce the correct 
          <termref def="dt-repltext">replacement text</termref>:
          see 
          <specref ref="intern-replacement" />.</p>
          <p>An internal entity is a 
          <termref def="dt-parsedent">parsed entity</termref>.</p>
          <p>Example of an internal entity declaration:</p>
          <eg>&lt;!ENTITY Pub-Status "This is a pre-release of the
          specification."&gt;</eg>
        </div3>
        <div3 id="sec-external-ent">
          <head>External Entities</head>
          <p>
            <termdef id="dt-extent" term="External Entity">If the
            entity is not internal, it is an 
            <term>external entity</term>, declared as
            follows:</termdef>
          </p>
          <scrap lang="ebnf">
            <head>External Entity Declaration</head>
            <prod id="NT-ExternalID" num="75">
              <lhs>ExternalID</lhs>
              <rhs>'SYSTEM' 
              <nt def="NT-S">S</nt>
              <nt def="NT-SystemLiteral">SystemLiteral</nt></rhs>
              <rhs>| 'PUBLIC' 
              <nt def="NT-S">S</nt>
              <nt def="NT-PubidLiteral">PubidLiteral</nt>
              <nt def="NT-S">S</nt>
              <nt def="NT-SystemLiteral">SystemLiteral</nt></rhs>
            </prod>
            <prod id="NT-NDataDecl" num="76">
              <lhs>NDataDecl</lhs>
              <rhs>
              <nt def="NT-S">S</nt>'NDATA' 
              <nt def="NT-S">S</nt>
              <nt def="NT-Name">Name</nt></rhs>
              <vc def="not-declared" />
            </prod>
          </scrap>
          <p>If the 
          <nt def="NT-NDataDecl">NDataDecl</nt>is present, this is
          a general 
          <termref def="dt-unparsed">unparsed entity</termref>;
          otherwise it is a parsed entity.</p>
          <vcnote id="not-declared">
            <head>Notation Declared</head>
            <p>The 
            <nt def="NT-Name">Name</nt>
            <rfc2119>MUST</rfc2119>match the declared name of a 
            <termref def="dt-notation">notation</termref>.</p>
          </vcnote>
          <p>
          <termdef id="dt-sysid" term="System Identifier">The 
          <nt def="NT-SystemLiteral">SystemLiteral</nt>is called
          the entity's 
          <term>system identifier</term>. It is meant to be
          converted to a URI reference (as defined in 
          <bibref ref="rfc3986" />), as part of the process of
          dereferencing it to obtain input for the XML processor to
          construct the entity's replacement text.</termdef>It is
          an error for a fragment identifier (beginning with a 
          <code>#</code>character) to be part of a system
          identifier. Unless otherwise provided by information
          outside the scope of this specification (e.g. a special
          XML element type defined by a particular DTD, or a
          processing instruction defined by a particular
          application specification), relative URIs are relative to
          the location of the resource within which the entity
          declaration occurs. This is defined to be the external
          entity containing the '&lt;' which starts the
          declaration, at the point when it is parsed as a
          declaration. A URI might thus be relative to the 
          <termref def="dt-docent">document entity</termref>, to
          the entity containing the 
          <termref def="dt-doctype">external DTD subset</termref>,
          or to some other 
          <termref def="dt-extent">external parameter
          entity</termref>. Attempts to retrieve the resource
          identified by a URI may be redirected at the parser level
          (for example, in an entity resolver) or below (at the
          protocol level, for example, via an HTTP 
          <code>Location:</code>header). In the absence of
          additional information outside the scope of this
          specification within the resource, the base URI of a
          resource is always the URI of the actual resource
          returned. In other words, it is the URI of the resource
          retrieved after all redirection has occurred.</p>
          <p>System identifiers (and other XML strings meant to be
          used as URI references) may contain characters that,
          according to 
          <bibref ref="rfc3986" />, must be escaped before a URI
          can be used to retrieve the referenced resource. The
          characters to be escaped are the control characters #x0
          to #x1F and #x7F (most of which cannot appear in XML),
          space #x20, the delimiters '&lt;' #x3C, '&gt;' #x3E and
          '"' #x22, the 
          <emph>unwise</emph>characters '{' #x7B, '}' #x7D, '|'
          #x7C, '\' #x5C, '^' #x5E and '`' #x60, as well as all
          characters above #x7F. Since escaping is not always a
          fully reversible process, it 
          <rfc2119>MUST</rfc2119>be performed only when absolutely
          necessary and as late as possible in a processing chain.
          In particular, neither the process of converting a
          relative URI to an absolute one nor the process of
          passing a URI reference to a process or software
          component responsible for dereferencing it 
          <rfc2119>SHOULD</rfc2119>trigger escaping. When escaping
          does occur, it 
          <rfc2119>MUST</rfc2119>be performed as follows:</p>
          <olist>
            <item>
              <p>Each character to be escaped is represented in
              UTF-8 
              <phrase diff="chg">
                <loc role="erratumref" href="E11" />
                <bibref ref="Unicode" />
              </phrase>as one or more bytes.</p>
            </item>
            <item>
              <p>The resulting bytes are escaped with the URI
              escaping mechanism (that is, converted to 
              <code>%</code>
              <var>HH</var>, where HH is the hexadecimal notation
              of the byte value).</p>
            </item>
            <item>
              <p>The original character is replaced by the
              resulting character sequence.</p>
            </item>
          </olist>
          <note diff="add">
            <p>In a future edition of this specification, the XML
            Core Working Group intends to replace the preceding
            paragraph and list of steps with a normative reference
            to an upcoming revision of IETF RFC 3987, which will
            define "Legacy Extended IRIs (LEIRIs)". When this
            revision is available, it is the intent of the XML Core
            WG to use it to replace language similar to the above
            in any future revisions of XML-related specifications
            under its purview.</p>
          </note>
          <p>
          <termdef id="dt-pubid" term="Public identifier">In
          addition to a system identifier, an external identifier
          may include a 
          <term>public identifier</term>.</termdef>An XML processor
          attempting to retrieve the entity's content may use any
          combination of the public and system identifiers as well
          as additional information outside the scope of this
          specification to try to generate an alternative URI
          reference. If the processor is unable to do so, it 
          <rfc2119>MUST</rfc2119>use the URI reference specified in
          the system literal. Before a match is attempted, all
          strings of white space in the public identifier 
          <rfc2119>MUST</rfc2119>be normalized to single space
          characters (#x20), and leading and trailing white space 
          <rfc2119>MUST</rfc2119>be removed.</p>
          <p>Examples of external entity declarations:</p>
          <eg>&lt;!ENTITY open-hatch SYSTEM
          "http://www.textuality.com/boilerplate/OpenHatch.xml"&gt;
          &lt;!ENTITY open-hatch PUBLIC "-//Textuality//TEXT
          Standard open-hatch boilerplate//EN"
          "http://www.textuality.com/boilerplate/OpenHatch.xml"&gt;
          &lt;!ENTITY hatch-pic SYSTEM "../grafix/OpenHatch.gif"
          NDATA gif &gt;</eg>
        </div3>
      </div2>
      <div2 id="TextEntities">
        <head>Parsed Entities</head>
        <div3 id="sec-TextDecl">
          <head>The Text Declaration</head>
          <p>External parsed entities 
          <rfc2119>SHOULD</rfc2119>each begin with a 
          <term>text declaration</term>.</p>
          <scrap lang="ebnf">
            <head>Text Declaration</head>
            <prodgroup pcw4="12.5" pcw5="13">
              <prod id="NT-TextDecl" num="77">
                <lhs>TextDecl</lhs>
                <rhs>'&lt;?xml' 
                <nt def="NT-VersionInfo">VersionInfo</nt>? 
                <nt def="NT-EncodingDecl">EncodingDecl</nt>
                <nt def="NT-S">S</nt>? '?&gt;'</rhs>
              </prod>
            </prodgroup>
          </scrap>
          <p>The text declaration 
          <rfc2119>MUST</rfc2119>be provided literally, not by
          reference to a parsed entity. The text declaration 
          <rfc2119>MUST NOT</rfc2119>appear at any position other
          than the beginning of an external parsed entity. The text
          declaration in an external parsed entity is not
          considered part of its 
          <termref def="dt-repltext">replacement
          text</termref>.</p>
        </div3>
        <div3 id="wf-entities">
          <head>Well-Formed Parsed Entities</head>
          <p>The document entity is well-formed if it matches the
          production labeled 
          <nt def="NT-document">document</nt>. An external general
          parsed entity is well-formed if it matches the production
          labeled 
          <nt def="NT-extParsedEnt">extParsedEnt</nt>. All external
          parameter entities are well-formed by definition.</p>
          <note>
            <p>Only parsed entities that are referenced directly or
            indirectly within the document are required to be
            well-formed.</p>
          </note>
          <scrap lang="ebnf">
            <head>Well-Formed External Parsed Entity</head>
            <prod id="NT-extParsedEnt" num="78">
              <lhs>extParsedEnt</lhs>
              <rhs>
              <nt def="NT-TextDecl">TextDecl</nt>? 
              <nt def="NT-content">content</nt></rhs>
            </prod>
          </scrap>
          <p>An internal general parsed entity is well-formed if
          its replacement text matches the production labeled 
          <nt def="NT-content">content</nt>. All internal parameter
          entities are well-formed by definition.</p>
          <p>A consequence of well-formedness in general entities
          is that the logical and physical structures in an XML
          document are properly nested; no 
          <termref def="dt-stag">start-tag</termref>, 
          <termref def="dt-etag">end-tag</termref>, 
          <termref def="dt-empty">empty-element tag</termref>, 
          <termref def="dt-element">element</termref>, 
          <termref def="dt-comment">comment</termref>, 
          <termref def="dt-pi">processing instruction</termref>, 
          <termref def="dt-charref">character reference</termref>,
          or 
          <termref def="dt-entref">entity reference</termref>can
          begin in one entity and end in another.</p>
        </div3>
        <div3 id="charencoding">
          <head>Character Encoding in Entities</head>
          <p>Each external parsed entity in an XML document may use
          a different encoding for its characters. All XML
          processors 
          <rfc2119>MUST</rfc2119>be able to read entities in both
          the UTF-8 and UTF-16 encodings. The terms 
          <quote>UTF-8</quote>and 
          <quote>UTF-16</quote>in this specification do not apply
          to 
          <phrase diff="del">
          <loc role="erratumref" href="E05" />character encodings
          with any other labels, even if the encodings or labels
          are very similar to UTF-8 or UTF-16.</phrase>
          <phrase diff="add">
          <loc role="erratumref" href="E05" />related character
          encodings, including but not limited to UTF-16BE,
          UTF-16LE, or CESU-8.</phrase></p>
          <p>Entities encoded in UTF-16 
          <rfc2119>MUST</rfc2119>and entities encoded in UTF-8 
          <rfc2119>MAY</rfc2119>begin with the Byte Order Mark
          described by Annex H of 
          <bibref ref="ISO10646-2000" />, section 
          <phrase diff="chg">
          <loc role="erratumref" href="E11" />16.8</phrase>of 
          <bibref ref="Unicode" />
          <phrase diff="del">
          <loc role="erratumref" href="E11" />, and section 2.7 of 
          <bibref ref="Unicode3" /></phrase>(the ZERO WIDTH
          NO-BREAK SPACE character, #xFEFF). This is an encoding
          signature, not part of either the markup or the character
          data of the XML document. XML processors 
          <rfc2119>MUST</rfc2119>be able to use this character to
          differentiate between UTF-8 and UTF-16 encoded
          documents.</p>
          <p diff="add">
          <loc role="erratumref" href="E06" />If the replacement
          text of an external entity is to begin with the character
          U+FEFF, and no text declaration is present, then a Byte
          Order Mark MUST be present, whether the entity is encoded
          in UTF-8 or UTF-16.</p>
          <p>Although an XML processor is required to read only
          entities in the UTF-8 and UTF-16 encodings, it is
          recognized that other encodings are used around the
          world, and it may be desired for XML processors to read
          entities that use them. In the absence of external
          character encoding information (such as MIME headers),
          parsed entities which are stored in an encoding other
          than UTF-8 or UTF-16 
          <rfc2119>MUST</rfc2119>begin with a text declaration (see
          
          <specref ref="sec-TextDecl" />) containing an encoding
          declaration:</p>
          <scrap lang="ebnf">
            <head>Encoding Declaration</head>
            <prod id="NT-EncodingDecl" num="80">
              <lhs>EncodingDecl</lhs>
              <rhs>
              <nt def="NT-S">S</nt>'encoding' 
              <nt def="NT-Eq">Eq</nt>('"' 
              <nt def="NT-EncName">EncName</nt>'"' | "'" 
              <nt def="NT-EncName">EncName</nt>"'" )</rhs>
            </prod>
            <prod id="NT-EncName" num="81">
              <lhs>EncName</lhs>
              <rhs>[A-Za-z] ([A-Za-z0-9._] | '-')*</rhs>
              <com>Encoding name contains only Latin
              characters</com>
            </prod>
          </scrap>
          <p>In the 
          <termref def="dt-docent">document entity</termref>, the
          encoding declaration is part of the 
          <termref def="dt-xmldecl">XML declaration</termref>. The 
          <nt def="NT-EncName">EncName</nt>is the name of the
          encoding used.</p>
          <p>In an encoding declaration, the values 
          <quote>
            <code>UTF-8</code>
          </quote>, 
          <quote>
            <code>UTF-16</code>
          </quote>, 
          <quote>
            <code>ISO-10646-UCS-2</code>
          </quote>, and 
          <quote>
            <code>ISO-10646-UCS-4</code>
          </quote>
          <rfc2119>SHOULD</rfc2119>be used for the various
          encodings and transformations of Unicode / ISO/IEC 10646,
          the values 
          <quote>
            <code>ISO-8859-1</code>
          </quote>, 
          <quote>
            <code>ISO-8859-2</code>
          </quote>, ... 
          <quote>
            <code>ISO-8859-</code>
            <var>n</var>
          </quote>(where 
          <var>n</var>is the part number) 
          <rfc2119>SHOULD</rfc2119>be used for the parts of ISO
          8859, and the values 
          <quote>
            <code>ISO-2022-JP</code>
          </quote>, 
          <quote>
            <code>Shift_JIS</code>
          </quote>, and 
          <quote>
            <code>EUC-JP</code>
          </quote>
          <rfc2119>SHOULD</rfc2119>be used for the various encoded
          forms of JIS X-0208-1997. It is 
          <rfc2119>RECOMMENDED</rfc2119>that character encodings
          registered (as 
          <emph>charset</emph>s) with the Internet Assigned Numbers
          Authority 
          <bibref ref="IANA" />, other than those just listed, be
          referred to using their registered names; other encodings
          
          <rfc2119>SHOULD</rfc2119>use names starting with an 
          <quote>x-</quote>prefix. XML processors 
          <rfc2119>SHOULD</rfc2119>match character encoding names
          in a case-insensitive way and 
          <rfc2119>SHOULD</rfc2119>either interpret an
          IANA-registered name as the encoding registered at IANA
          for that name or treat it as unknown (processors are, of
          course, not required to support all IANA-registered
          encodings).</p>
          <p>In the absence of information provided by an external
          transport protocol (e.g. HTTP or MIME), it is a 
          <termref def="dt-fatal">fatal error</termref>for an
          entity including an encoding declaration to be presented
          to the XML processor in an encoding other than that named
          in the declaration, or for an entity which begins with
          neither a Byte Order Mark nor an encoding declaration to
          use an encoding other than UTF-8. Note that since ASCII
          is a subset of UTF-8, ordinary ASCII entities do not
          strictly need an encoding declaration.</p>
          <p>It is a 
          <termref def="dt-fatal">fatal error</termref>for a 
          <nt def="NT-TextDecl">TextDecl</nt>to occur other than at
          the beginning of an external entity.</p>
          <p>It is a 
          <termref def="dt-fatal">fatal error</termref>when an XML
          processor encounters an entity with an encoding that it
          is unable to process. It is a 
          <termref def="dt-fatal">fatal error</termref>if an XML
          entity is determined (via default, encoding declaration,
          or higher-level protocol) to be in a certain encoding but
          contains byte sequences that are not legal in that
          encoding. Specifically, it is a fatal error if an entity
          encoded in UTF-8 contains any 
          <phrase diff="del">
          <loc role="erratumref" href="E11" />irregular</phrase>
          <phrase diff="add">
          <loc role="erratumref"
          href="E11" />ill-formed</phrase>code unit sequences, as
          defined in 
          <phrase diff="add">
          <loc role="erratumref" href="E11" />section 3.9
          of</phrase>Unicode 
          <phrase diff="del">
          <loc role="erratumref" href="E11" />3.1</phrase>
          <phrase diff="chg">
            <loc role="erratumref" href="E11" />
            <bibref ref="Unicode" />
          </phrase>. Unless an encoding is determined by a
          higher-level protocol, it is also a 
          <termref def="dt-fatal">fatal error</termref>if an XML
          entity contains no encoding declaration and its content
          is not legal UTF-8 or UTF-16.</p>
          <p>Examples of text declarations containing encoding
          declarations:</p>
          <eg>&lt;?xml encoding='UTF-8'?&gt; &lt;?xml
          encoding='EUC-JP'?&gt;</eg>
        </div3>
      </div2>
      <div2 id="entproc">
        <head>XML Processor Treatment of Entities and
        References</head>
        <p>The table below summarizes the contexts in which
        character references, entity references, and invocations of
        unparsed entities might appear and the 
        <rfc2119>REQUIRED</rfc2119>behavior of an 
        <termref def="dt-xml-proc">XML processor</termref>in each
        case. The labels in the leftmost column describe the
        recognition context: 
        <glist>
          <gitem>
            <label>Reference in Content</label>
            <def>
              <p>as a reference anywhere after the 
              <termref def="dt-stag">start-tag</termref>and before
              the 
              <termref def="dt-etag">end-tag</termref>of an
              element; corresponds to the nonterminal 
              <nt def="NT-content">content</nt>.</p>
            </def>
          </gitem>
          <gitem>
            <label>Reference in Attribute Value</label>
            <def>
              <p>as a reference within either the value of an
              attribute in a 
              <termref def="dt-stag">start-tag</termref>, or a
              default value in an 
              <termref def="dt-attdecl">attribute
              declaration</termref>; corresponds to the nonterminal
              
              <nt def="NT-AttValue">AttValue</nt>.</p>
            </def>
          </gitem>
          <gitem>
            <label>Occurs as Attribute Value</label>
            <def>
              <p>as a 
              <nt def="NT-Name">Name</nt>, not a reference,
              appearing either as the value of an attribute which
              has been declared as type 
              <kw>ENTITY</kw>, or as one of the space-separated
              tokens in the value of an attribute which has been
              declared as type 
              <kw>ENTITIES</kw>.</p>
            </def>
          </gitem>
          <gitem>
            <label>Reference in Entity Value</label>
            <def>
              <p>as a reference within a parameter or internal
              entity's 
              <termref def="dt-litentval">literal entity
              value</termref>in the entity's declaration;
              corresponds to the nonterminal 
              <nt def="NT-EntityValue">EntityValue</nt>.</p>
            </def>
          </gitem>
          <gitem>
            <label>Reference in DTD</label>
            <def>
              <p>as a reference within either the internal or
              external subsets of the 
              <termref def="dt-doctype">DTD</termref>, but outside
              of an 
              <nt def="NT-EntityValue">EntityValue</nt>, 
              <nt def="NT-AttValue">AttValue</nt>, 
              <nt def="NT-PI">PI</nt>, 
              <nt def="NT-Comment">Comment</nt>, 
              <nt def="NT-SystemLiteral">SystemLiteral</nt>, 
              <nt def="NT-PubidLiteral">PubidLiteral</nt>, or the
              contents of an ignored conditional section (see 
              <specref ref="sec-condition-sect" />).</p>
              <p>.</p>
            </def>
          </gitem>
        </glist></p>
        <table border="1" frame="border" cellpadding="7">
          <tbody align="center">
            <tr>
              <td rowspan="2" colspan="1" />
              <td colspan="4" align="center" valign="bottom">Entity
              Type</td>
              <td rowspan="2" align="center">Character</td>
            </tr>
            <tr align="center" valign="bottom">
              <td>Parameter</td>
              <td>Internal General</td>
              <td>External Parsed General</td>
              <td>Unparsed</td>
            </tr>
            <tr align="center" valign="middle">
              <td align="right">Reference in Content</td>
              <td>
                <titleref href="#not-recognized">Not
                recognized</titleref>
              </td>
              <td>
                <titleref href="#included">Included</titleref>
              </td>
              <td>
                <titleref href="#include-if-valid">Included if
                validating</titleref>
              </td>
              <td>
                <titleref href="#forbidden">Forbidden</titleref>
              </td>
              <td>
                <titleref href="#included">Included</titleref>
              </td>
            </tr>
            <tr align="center" valign="middle">
              <td align="right">Reference in Attribute Value</td>
              <td>
                <titleref href="#not-recognized">Not
                recognized</titleref>
              </td>
              <td>
                <titleref href="#inliteral">Included in
                literal</titleref>
              </td>
              <td>
                <titleref href="#forbidden">Forbidden</titleref>
              </td>
              <td>
                <titleref href="#forbidden">Forbidden</titleref>
              </td>
              <td>
                <titleref href="#included">Included</titleref>
              </td>
            </tr>
            <tr align="center" valign="middle">
              <td align="right">Occurs as Attribute Value</td>
              <td>
                <titleref href="#not-recognized">Not
                recognized</titleref>
              </td>
              <td>
                <titleref href="#forbidden">Forbidden</titleref>
              </td>
              <td>
                <titleref href="#forbidden">Forbidden</titleref>
              </td>
              <td>
                <titleref href="#notify">Notify</titleref>
              </td>
              <td>
                <titleref href="#not-recognized">Not
                recognized</titleref>
              </td>
            </tr>
            <tr align="center" valign="middle">
              <td align="right">Reference in EntityValue</td>
              <td>
                <titleref href="#inliteral">Included in
                literal</titleref>
              </td>
              <td>
                <titleref href="#bypass">Bypassed</titleref>
              </td>
              <td>
                <titleref href="#bypass">Bypassed</titleref>
              </td>
              <td>
                <titleref href="#error">Error</titleref>
              </td>
              <td>
                <titleref href="#included">Included</titleref>
              </td>
            </tr>
            <tr align="center" valign="middle">
              <td align="right">Reference in DTD</td>
              <td>
                <titleref href="#as-PE">Included as PE</titleref>
              </td>
              <td>
                <titleref href="#forbidden">Forbidden</titleref>
              </td>
              <td>
                <titleref href="#forbidden">Forbidden</titleref>
              </td>
              <td>
                <titleref href="#forbidden">Forbidden</titleref>
              </td>
              <td>
                <titleref href="#forbidden">Forbidden</titleref>
              </td>
            </tr>
          </tbody>
        </table>
        <div3 id="not-recognized">
          <head>Not Recognized</head>
          <p>Outside the DTD, the 
          <code>%</code>character has no special significance;
          thus, what would be parameter entity references in the
          DTD are not recognized as markup in 
          <nt def="NT-content">content</nt>. Similarly, the names
          of unparsed entities are not recognized except when they
          appear in the value of an appropriately declared
          attribute.</p>
        </div3>
        <div3 id="included">
          <head>Included</head>
          <p>
          <termdef id="dt-include" term="Include">An entity is 
          <term>included</term>when its 
          <termref def="dt-repltext">replacement text</termref>is
          retrieved and processed, in place of the reference
          itself, as though it were part of the document at the
          location the reference was recognized.</termdef>The
          replacement text may contain both 
          <termref def="dt-chardata">character data</termref>and
          (except for parameter entities) 
          <termref def="dt-markup">markup</termref>, which 
          <rfc2119>MUST</rfc2119>be recognized in the usual way.
          (The string 
          <quote>
            <code>AT&amp;amp;T;</code>
          </quote>expands to 
          <quote>
            <code>AT&amp;T;</code>
          </quote>and the remaining ampersand is not recognized as
          an entity-reference delimiter.) A character reference is 
          <term>included</term>when the indicated character is
          processed in place of the reference itself.</p>
        </div3>
        <div3 id="include-if-valid">
          <head>Included If Validating</head>
          <p>When an XML processor recognizes a reference to a
          parsed entity, in order to 
          <termref def="dt-valid">validate</termref>the document,
          the processor 
          <rfc2119>MUST</rfc2119>
          <termref def="dt-include">include</termref>its
          replacement text. If the entity is external, and the
          processor is not attempting to validate the XML document,
          the processor 
          <rfc2119>MAY</rfc2119>, but need not, include the
          entity's replacement text. If a non-validating processor
          does not include the replacement text, it 
          <rfc2119>MUST</rfc2119>inform the application that it
          recognized, but did not read, the entity.</p>
          <p>This rule is based on the recognition that the
          automatic inclusion provided by the SGML and XML entity
          mechanism, primarily designed to support modularity in
          authoring, is not necessarily appropriate for other
          applications, in particular document browsing. Browsers,
          for example, when encountering an external parsed entity
          reference, might choose to provide a visual indication of
          the entity's presence and retrieve it for display only on
          demand.</p>
        </div3>
        <div3 id="forbidden">
          <head>Forbidden</head>
          <p>The following are forbidden, and constitute 
          <termref def="dt-fatal">fatal errors</termref>:</p>
          <ulist>
            <item>
              <p>the appearance of a reference to an 
              <termref def="dt-unparsed">unparsed entity</termref>,
              except in the 
              <nt def="NT-EntityValue">EntityValue</nt>in an entity
              declaration.</p>
            </item>
            <item>
              <p>the appearance of any character or general-entity
              reference in the DTD except within an 
              <nt def="NT-EntityValue">EntityValue</nt>or 
              <nt def="NT-AttValue">AttValue</nt>.</p>
            </item>
            <item>
              <p>a reference to an external entity in an attribute
              value.</p>
            </item>
          </ulist>
        </div3>
        <div3 id="inliteral">
          <head>Included in Literal</head>
          <p>When an 
          <termref def="dt-entref">entity
          reference</termref>appears in an attribute value, or a
          parameter entity reference appears in a literal entity
          value, its 
          <termref def="dt-repltext">replacement text</termref>
          <rfc2119>MUST</rfc2119>be processed in place of the
          reference itself as though it were part of the document
          at the location the reference was recognized, except that
          a single or double quote character in the replacement
          text 
          <rfc2119>MUST</rfc2119>always be treated as a normal data
          character and 
          <rfc2119>MUST NOT</rfc2119>terminate the literal. For
          example, this is well-formed:</p>
          <eg>&lt;!ENTITY % YN '"Yes"' &gt; &lt;!ENTITY WhatHeSaid
          "He said %YN;" &gt;</eg>
          <p>while this is not:</p>
          <eg>&lt;!ENTITY EndAttr "27'" &gt; &lt;element
          attribute='a-&amp;EndAttr;&gt;</eg>
        </div3>
        <div3 id="notify">
          <head>Notify</head>
          <p>When the name of an 
          <termref def="dt-unparsed">unparsed
          entity</termref>appears as a token in the value of an
          attribute of declared type 
          <kw>ENTITY</kw>or 
          <kw>ENTITIES</kw>, a validating processor 
          <rfc2119>MUST</rfc2119>inform the application of the 
          <termref def="dt-sysid">system</termref>and 
          <termref def="dt-pubid">public</termref>(if any)
          identifiers for both the entity and its associated 
          <termref def="dt-notation">notation</termref>.</p>
        </div3>
        <div3 id="bypass">
          <head>Bypassed</head>
          <p>When a general entity reference appears in the 
          <nt def="NT-EntityValue">EntityValue</nt>in an entity
          declaration, it 
          <rfc2119>MUST</rfc2119>be bypassed and left as is.</p>
        </div3>
        <div3 id="as-PE">
          <head>Included as PE</head>
          <p>Just as with external parsed entities, parameter
          entities need only be 
          <titleref href="#include-if-valid">included if
          validating</titleref>. When a parameter-entity reference
          is recognized in the DTD and included, its 
          <termref def="dt-repltext">replacement text</termref>
          <rfc2119>MUST</rfc2119>be enlarged by the attachment of
          one leading and one following space (#x20) character; the
          intent is to constrain the replacement text of parameter
          entities to contain an integral number of grammatical
          tokens in the DTD. This behavior 
          <rfc2119>MUST NOT</rfc2119>apply to parameter entity
          references within entity values; these are described in 
          <specref ref="inliteral" />.</p>
        </div3>
        <div3 id="error">
          <head>Error</head>
          <p>It is an 
          <termref def="dt-error">error</termref>for a reference to
          an unparsed entity to appear in the 
          <nt def="NT-EntityValue">EntityValue</nt>in an entity
          declaration.</p>
        </div3>
      </div2>
      <div2 id="intern-replacement">
        <head>Construction of Entity Replacement Text</head>
        <p>In discussing the treatment of entities, it is useful to
        distinguish two forms of the entity's value. 
        <termdef id="dt-litentval" term="Literal Entity Value">For
        an internal entity, the 
        <term>literal entity value</term>is the quoted string
        actually present in the entity declaration, corresponding
        to the non-terminal 
        <nt def="NT-EntityValue">EntityValue</nt>.</termdef>
        <termdef id="dt-extlitentval" term="Literal Entity Value">
        For an external entity, the 
        <term>literal entity value</term>is the exact text
        contained in the entity.</termdef>
        <termdef id="dt-repltext" term="Replacement Text">For an
        internal entity, the 
        <term>replacement text</term>is the content of the entity,
        after replacement of character references and
        parameter-entity references.</termdef>
        <termdef id="dt-extrepltext" term="Replacement Text">For an
        external entity, the 
        <term>replacement text</term>is the content of the entity,
        after stripping the text declaration (leaving any
        surrounding whitespace) if there is one but without any
        replacement of character references or parameter-entity
        references.</termdef></p>
        <p>The literal entity value as given in an internal entity
        declaration (
        <nt def="NT-EntityValue">EntityValue</nt>) may contain
        character, parameter-entity, and general-entity references.
        Such references 
        <rfc2119>MUST</rfc2119>be contained entirely within the
        literal entity value. The actual replacement text that is 
        <termref def="dt-include">included</termref>(or 
        <termref def="inliteral">included in literal</termref>) as
        described above 
        <rfc2119>MUST</rfc2119>contain the 
        <emph>replacement text</emph>of any parameter entities
        referred to, and 
        <rfc2119>MUST</rfc2119>contain the character referred to,
        in place of any character references in the literal entity
        value; however, general-entity references 
        <rfc2119>MUST</rfc2119>be left as-is, unexpanded. For
        example, given the following declarations:</p>
        <eg lang="fr">&lt;!ENTITY % pub "&amp;#xc9;ditions
        Gallimard" &gt; &lt;!ENTITY rights "All rights reserved"
        &gt; &lt;!ENTITY book "La Peste: Albert Camus, &amp;#xA9;
        1947 %pub;. &amp;rights;" &gt;</eg>
        <p>then the replacement text for the entity 
        <quote>
          <code>book</code>
        </quote>is:</p>
        <eg lang="fr">La Peste: Albert Camus, &#194;&#169; 1947
        &#195;&#8240;ditions Gallimard. &amp;rights;</eg>
        <p>The general-entity reference 
        <quote>
          <code>&amp;rights;</code>
        </quote>would be expanded should the reference 
        <quote>
          <code>&amp;book;</code>
        </quote>appear in the document's content or an attribute
        value.</p>
        <p>These simple rules may have complex interactions; for a
        detailed discussion of a difficult example, see 
        <specref ref="sec-entexpand" />.</p>
      </div2>
      <div2 id="sec-predefined-ent">
        <head>Predefined Entities</head>
        <p>
          <termdef id="dt-escape" term="escape">Entity and
          character references may both be used to 
          <term>escape</term>the left angle bracket, ampersand, and
          other delimiters. A set of general entities (
          <code>amp</code>, 
          <code>lt</code>, 
          <code>gt</code>, 
          <code>apos</code>, 
          <code>quot</code>) is specified for this purpose. Numeric
          character references may also be used; they are expanded
          immediately when recognized and 
          <rfc2119>MUST</rfc2119>be treated as character data, so
          the numeric character references 
          <quote>
            <code>&amp;#60;</code>
          </quote>and 
          <quote>
            <code>&amp;#38;</code>
          </quote>may be used to escape 
          <code>&lt;</code>and 
          <code>&amp;</code>when they occur in character
          data.</termdef>
        </p>
        <p>All XML processors 
        <rfc2119>MUST</rfc2119>recognize these entities whether
        they are declared or not. 
        <termref def="dt-interop">For interoperability</termref>,
        valid XML documents 
        <rfc2119>SHOULD</rfc2119>declare these entities, like any
        others, before using them. If the entities 
        <code>lt</code>or 
        <code>amp</code>are declared, they 
        <rfc2119>MUST</rfc2119>be declared as internal entities
        whose replacement text is a character reference to the
        respective character (less-than sign or ampersand) being
        escaped; the double escaping is 
        <rfc2119>REQUIRED</rfc2119>for these entities so that
        references to them produce a well-formed result. If the
        entities 
        <code>gt</code>, 
        <code>apos</code>, or 
        <code>quot</code>are declared, they 
        <rfc2119>MUST</rfc2119>be declared as internal entities
        whose replacement text is the single character being
        escaped (or a character reference to that character; the
        double escaping here is 
        <rfc2119>OPTIONAL</rfc2119>but harmless). For example:</p>
        <eg>&lt;!ENTITY lt "&amp;#38;#60;"&gt; &lt;!ENTITY gt
        "&amp;#62;"&gt; &lt;!ENTITY amp "&amp;#38;#38;"&gt;
        &lt;!ENTITY apos "&amp;#39;"&gt; &lt;!ENTITY quot
        "&amp;#34;"&gt;</eg>
      </div2>
      <div2 id="Notations">
        <head>Notation Declarations</head>
        <p>
          <termdef id="dt-notation" term="Notation">
          <term>Notations</term>identify by name the format of 
          <termref def="dt-unparsed">unparsed entities</termref>,
          the format of elements which bear a notation attribute,
          or the application to which a 
          <termref def="dt-pi">processing instruction</termref>is
          addressed.</termdef>
        </p>
        <p>
          <termdef id="dt-notdecl" term="Notation Declaration">
          <term>Notation declarations</term>provide a name for the
          notation, for use in entity and attribute-list
          declarations and in attribute specifications, and an
          external identifier for the notation which may allow an
          XML processor or its client application to locate a
          helper application capable of processing data in the
          given notation.</termdef>
        </p>
        <scrap lang="ebnf">
          <head>Notation Declarations</head>
          <prod id="NT-NotationDecl" num="82">
            <lhs>NotationDecl</lhs>
            <rhs>'&lt;!NOTATION' 
            <nt def="NT-S">S</nt>
            <nt def="NT-Name">Name</nt>
            <nt def="NT-S">S</nt>(
            <nt def="NT-ExternalID">ExternalID</nt>| 
            <nt def="NT-PublicID">PublicID</nt>) 
            <nt def="NT-S">S</nt>? '&gt;'</rhs>
            <vc def="UniqueNotationName" />
          </prod>
          <prod id="NT-PublicID" num="83">
            <lhs>PublicID</lhs>
            <rhs>'PUBLIC' 
            <nt def="NT-S">S</nt>
            <nt def="NT-PubidLiteral">PubidLiteral</nt></rhs>
          </prod>
        </scrap>
        <vcnote id="UniqueNotationName">
          <head>Unique Notation Name</head>
          <p>A given 
          <nt def="NT-Name">Name</nt>
          <rfc2119>MUST NOT</rfc2119>be declared in more than one
          notation declaration.</p>
        </vcnote>
        <p>XML processors 
        <rfc2119>MUST</rfc2119>provide applications with the name
        and external identifier(s) of any notation declared and
        referred to in an attribute value, attribute definition, or
        entity declaration. They 
        <rfc2119>MAY</rfc2119>additionally resolve the external
        identifier into the 
        <termref def="dt-sysid">system identifier</termref>, file
        name, or other information needed to allow the application
        to call a processor for data in the notation described. (It
        is not an error, however, for XML documents to declare and
        refer to notations for which notation-specific applications
        are not available on the system where the XML processor or
        application is running.)</p>
      </div2>
      <div2 id="sec-doc-entity">
        <head>Document Entity</head>
        <p>
        <termdef id="dt-docent" term="Document Entity">The 
        <term>document entity</term>serves as the root of the
        entity tree and a starting-point for an 
        <termref def="dt-xml-proc">XML
        processor</termref>.</termdef>This specification does not
        specify how the document entity is to be located by an XML
        processor; unlike other entities, the document entity has
        no name and might well appear on a processor input stream
        without any identification at all.</p>
      </div2>
    </div1>
    <div1 id="sec-conformance">
      <head>Conformance</head>
      <div2 id="proc-types">
        <head>Validating and Non-Validating Processors</head>
        <p>Conforming 
        <termref def="dt-xml-proc">XML processors</termref>fall
        into two classes: validating and non-validating.</p>
        <p>Validating and non-validating processors alike 
        <rfc2119>MUST</rfc2119>report violations of this
        specification's well-formedness constraints in the content
        of the 
        <termref def="dt-docent">document entity</termref>and any
        other 
        <termref def="dt-parsedent">parsed entities</termref>that
        they read.</p>
        <p>
        <termdef id="dt-validating" term="Validating Processor">
        <term>Validating processors</term>
        <rfc2119>MUST</rfc2119>, at user option, report violations
        of the constraints expressed by the declarations in the 
        <termref def="dt-doctype">DTD</termref>, and failures to
        fulfill the validity constraints given in this
        specification.</termdef>To accomplish this, validating XML
        processors 
        <rfc2119>MUST</rfc2119>read and process the entire DTD and
        all external parsed entities referenced in the
        document.</p>
        <p>Non-validating processors are 
        <rfc2119>REQUIRED</rfc2119>to check only the 
        <termref def="dt-docent">document entity</termref>,
        including the entire internal DTD subset, for
        well-formedness. 
        <termdef id="dt-use-mdecl" term="Process Declarations">
        While they are not required to check the document for
        validity, they are 
        <rfc2119>REQUIRED</rfc2119>to 
        <term>process</term>all the declarations they read in the
        internal DTD subset and in any parameter entity that they
        read, up to the first reference to a parameter entity that
        they do 
        <emph>not</emph>read; that is to say, they 
        <rfc2119>MUST</rfc2119>use the information in those
        declarations to 
        <titleref href="#AVNormalize">normalize</titleref>attribute
        values, 
        <titleref href="#included">include</titleref>the
        replacement text of internal entities, and supply 
        <titleref href="#sec-attr-defaults">default attribute
        values</titleref>.</termdef>Except when 
        <code>standalone="yes"</code>, they 
        <rfc2119>MUST NOT</rfc2119>
        <termref def="dt-use-mdecl">process</termref>
        <termref def="dt-entdecl">entity declarations</termref>or 
        <termref def="dt-attdecl">attribute-list
        declarations</termref>encountered after a reference to a
        parameter entity that is not read, since the entity may
        have contained overriding declarations; when 
        <code>standalone="yes"</code>, processors 
        <rfc2119>MUST</rfc2119>process these declarations.</p>
        <p>Note that when processing invalid documents with a
        non-validating processor the application may not be
        presented with consistent information. For example, several
        requirements for uniqueness within the document may not be
        met, including more than one element with the same id,
        duplicate declarations of elements or notations with the
        same name, etc. In these cases the behavior of the parser
        with respect to reporting such information to the
        application is undefined.</p>
      </div2>
      <div2 id="safe-behavior">
        <head>Using XML Processors</head>
        <p>The behavior of a validating XML processor is highly
        predictable; it must read every piece of a document and
        report all well-formedness and validity violations. Less is
        required of a non-validating processor; it need not read
        any part of the document other than the document entity.
        This has two effects that may be important to users of XML
        processors:</p>
        <ulist>
          <item>
            <p>Certain well-formedness errors, specifically those
            that require reading external entities, may fail to be
            detected by a non-validating processor. Examples
            include the constraints entitled 
            <titleref href="#wf-entdeclared">Entity
            Declared</titleref>, 
            <titleref href="#textent">Parsed Entity</titleref>, and
            
            <titleref href="#norecursion">No Recursion</titleref>,
            as well as some of the cases described as 
            <titleref href="#forbidden">forbidden</titleref>in 
            <specref ref="entproc" />.</p>
          </item>
          <item>
            <p>The information passed from the processor to the
            application may vary, depending on whether the
            processor reads parameter and external entities. For
            example, a non-validating processor may fail to 
            <titleref href="#AVNormalize">
            normalize</titleref>attribute values, 
            <titleref href="#included">include</titleref>the
            replacement text of internal entities, or supply 
            <titleref href="#sec-attr-defaults">default attribute
            values</titleref>, where doing so depends on having
            read declarations in external or parameter entities
            <phrase diff="add">
            <loc role="erratumref" href="E04" />, or in the
            internal subset after an unread parameter entity
            reference</phrase>.</p>
          </item>
        </ulist>
        <p>For maximum reliability in interoperating between
        different XML processors, applications which use
        non-validating processors 
        <rfc2119>SHOULD NOT</rfc2119>rely on any behaviors not
        required of such processors. Applications which require DTD
        facilities not related to validation (such as the
        declaration of default attributes and internal entities
        that are or may be specified in external entities) 
        <rfc2119>SHOULD</rfc2119>use validating XML processors.</p>
      </div2>
    </div1>
    <div1 id="sec-notation">
      <head>Notation</head>
      <p>The formal grammar of XML is given in this specification
      using a simple Extended Backus-Naur Form (EBNF) notation.
      Each rule in the grammar defines one symbol, in the form</p>
      <eg>symbol ::= expression</eg>
      <p>Symbols are written with an initial capital letter if they
      are the start symbol of a regular language, otherwise with an
      initial lowercase letter. Literal strings are quoted.</p>
      <p>Within the expression on the right-hand side of a rule,
      the following expressions are used to match strings of one or
      more characters: 
      <glist>
        <gitem>
          <label>
            <code>#xN</code>
          </label>
          <def>
            <p>where 
            <code>N</code>is a hexadecimal integer, the expression
            matches the character whose number (code point) in
            ISO/IEC 10646 is 
            <code>N</code>. The number of leading zeros in the 
            <code>#xN</code>form is insignificant.</p>
          </def>
        </gitem>
        <gitem>
          <label>
          <code>[a-zA-Z]</code>, 
          <code>[#xN-#xN]</code></label>
          <def>
            <p>matches any 
            <nt def="NT-Char">Char</nt>with a value in the range(s)
            indicated (inclusive).</p>
          </def>
        </gitem>
        <gitem>
          <label>
          <code>[abc]</code>, 
          <code>[#xN#xN#xN]</code></label>
          <def>
            <p>matches any 
            <nt def="NT-Char">Char</nt>with a value among the
            characters enumerated. Enumerations and ranges can be
            mixed in one set of brackets.</p>
          </def>
        </gitem>
        <gitem>
          <label>
          <code>[^a-z]</code>, 
          <code>[^#xN-#xN]</code></label>
          <def>
            <p>matches any 
            <nt def="NT-Char">Char</nt>with a value 
            <emph>outside</emph>the range indicated.</p>
          </def>
        </gitem>
        <gitem>
          <label>
          <code>[^abc]</code>, 
          <code>[^#xN#xN#xN]</code></label>
          <def>
            <p>matches any 
            <nt def="NT-Char">Char</nt>with a value not among the
            characters given. Enumerations and ranges of forbidden
            values can be mixed in one set of brackets.</p>
          </def>
        </gitem>
        <gitem>
          <label>
            <code>"string"</code>
          </label>
          <def>
            <p>matches a literal string 
            <termref def="dt-match">matching</termref>that given
            inside the double quotes.</p>
          </def>
        </gitem>
        <gitem>
          <label>
            <code>'string'</code>
          </label>
          <def>
            <p>matches a literal string 
            <termref def="dt-match">matching</termref>that given
            inside the single quotes.</p>
          </def>
        </gitem>
      </glist>These symbols may be combined to match more complex
      patterns as follows, where 
      <code>A</code>and 
      <code>B</code>represent simple expressions: 
      <glist>
        <gitem>
          <label>(
          <code>expression</code>)</label>
          <def>
            <p>
            <code>expression</code>is treated as a unit and may be
            combined as described in this list.</p>
          </def>
        </gitem>
        <gitem>
          <label>
            <code>A?</code>
          </label>
          <def>
            <p>matches 
            <code>A</code>or nothing; optional 
            <code>A</code>.</p>
          </def>
        </gitem>
        <gitem>
          <label>
            <code>A B</code>
          </label>
          <def>
            <p>matches 
            <code>A</code>followed by 
            <code>B</code>. This operator has higher precedence
            than alternation; thus 
            <code>A B | C D</code>is identical to 
            <code>(A B) | (C D)</code>.</p>
          </def>
        </gitem>
        <gitem>
          <label>
            <code>A | B</code>
          </label>
          <def>
            <p>matches 
            <code>A</code>or 
            <code>B</code>.</p>
          </def>
        </gitem>
        <gitem>
          <label>
            <code>A - B</code>
          </label>
          <def>
            <p>matches any string that matches 
            <code>A</code>but does not match 
            <code>B</code>.</p>
          </def>
        </gitem>
        <gitem>
          <label>
            <code>A+</code>
          </label>
          <def>
            <p>matches one or more occurrences of 
            <code>A</code>. Concatenation has higher precedence
            than alternation; thus 
            <code>A+ | B+</code>is identical to 
            <code>(A+) | (B+)</code>.</p>
          </def>
        </gitem>
        <gitem>
          <label>
            <code>A*</code>
          </label>
          <def>
            <p>matches zero or more occurrences of 
            <code>A</code>. Concatenation has higher precedence
            than alternation; thus 
            <code>A* | B*</code>is identical to 
            <code>(A*) | (B*)</code>.</p>
          </def>
        </gitem>
      </glist>Other notations used in the productions are: 
      <glist>
        <gitem>
          <label>
            <code>/* ... */</code>
          </label>
          <def>
            <p>comment.</p>
          </def>
        </gitem>
        <gitem>
          <label>
            <code>[ wfc: ... ]</code>
          </label>
          <def>
            <p>well-formedness constraint; this identifies by name
            a constraint on 
            <termref def="dt-wellformed">
            well-formed</termref>documents associated with a
            production.</p>
          </def>
        </gitem>
        <gitem>
          <label>
            <code>[ vc: ... ]</code>
          </label>
          <def>
            <p>validity constraint; this identifies by name a
            constraint on 
            <termref def="dt-valid">valid</termref>documents
            associated with a production.</p>
          </def>
        </gitem>
      </glist></p>
    </div1>
  </body>
  <back>
    <div1 id="sec-bibliography">
      <head>References</head>
      <div2 id="sec-existing-stds">
        <head>Normative References</head>
        <blist>
          <bibl id="IANA"
          href="http://www.iana.org/assignments/character-sets"
          key="IANA-CHARSETS">(Internet Assigned Numbers Authority)
          
          <titleref>Official Names for Character Sets</titleref>,
          ed. Keld Simonsen et al.</bibl>
          <bibl id="rfc2119"
          href="http://www.ietf.org/rfc/rfc2119.txt"
          key="IETF RFC 2119">IETF (Internet Engineering Task
          Force). 
          <titleref>RFC 2119: Key words for use in RFCs to Indicate
          Requirement Levels</titleref>. Scott Bradner,
          1997.</bibl>
          <bibl id="RFC1766" key="IETF BCP 47" diff="chg">
          <loc role="erratumref" href="E01" />IETF (Internet
          Engineering Task Force). 
          <titleref>BCP 47, consisting of 
          <loc href="http://tools.ietf.org/html/rfc4646">RFC 4646:
          Tags for Identifying Languages</loc>, and 
          <loc href="http://tools.ietf.org/html/rfc4647">RFC 4647:
          Matching of Language Tags</loc></titleref>, A. Phillips,
          M. Davis. 2006.</bibl>
          <bibl id="rfc3986"
          href="http://www.ietf.org/rfc/rfc3986.txt"
          key="IETF RFC 3986">IETF (Internet Engineering Task
          Force). 
          <titleref>RFC 3986: Uniform Resource Identifier (URI):
          Generic Syntax</titleref>. T. Berners-Lee, R. Fielding,
          L. Masinter. 2005.</bibl>
          <bibl id="ISO10646" key="ISO/IEC 10646">ISO
          (International Organization for Standardization). 
          <titleref>ISO/IEC 10646-1:2000. Information technology
          &#226;&#8364;&#8221; Universal Multiple-Octet Coded
          Character Set (UCS) &#226;&#8364;&#8221; Part 1:
          Architecture and Basic Multilingual Plane</titleref>and 
          <titleref>ISO/IEC 10646-2:2001. Information technology
          &#226;&#8364;&#8221; Universal Multiple-Octet Coded
          Character Set (UCS) &#226;&#8364;&#8221; Part 2:
          Supplementary Planes</titleref>, as, from time to time,
          amended, replaced by a new edition or expanded by the
          addition of new parts. [Geneva]: International
          Organization for Standardization. (See 
          <loc href="http://www.iso.org/iso/home.htm">
          http://www.iso.org/iso/home.htm</loc>for the latest
          version.)</bibl>
          <bibl id="ISO10646-2000" key="ISO/IEC 10646:2000">ISO
          (International Organization for Standardization). 
          <titleref>ISO/IEC 10646-1:2000. Information technology
          &#226;&#8364;&#8221; Universal Multiple-Octet Coded
          Character Set (UCS) &#226;&#8364;&#8221; Part 1:
          Architecture and Basic Multilingual
          Plane.</titleref>[Geneva]: International Organization for
          Standardization, 2000.</bibl>
          <bibl id="Unicode" key="Unicode">The Unicode Consortium. 
          <emph>The Unicode Standard, Version 
          <phrase diff="chg">
          <loc role="erratumref"
          href="E11" />5.0.0,</phrase></emph>
          <phrase diff="del">
          <loc role="erratumref" href="E11" />Reading, Mass.:
          Addison-Wesley Developers Press, 1996</phrase>
          <phrase diff="add">
          <loc role="erratumref" href="E11" />defined by: The
          Unicode Standard, Version 5.0 (Boston, MA,
          Addison-Wesley, 2007. ISBN
          0-321-48091-0)</phrase>.</bibl>
          <bibl id="unipart15" key="UnicodeNormal"
          href="http://unicode.org/reports/tr15/">The Unicode
          Consortium. 
          <titleref>Unicode normalization forms</titleref>. Mark
          Davis and Martin Durst. 2008.</bibl>
          <bibl id="Unicode3" key="Unicode3" diff="del">
          <loc role="erratumref" href="E11" />The Unicode
          Consortium. 
          <emph>The Unicode Standard, Version 3.2</emph>, defined
          by: 
          <emph>The Unicode Standard, Version 3.0</emph>(Reading,
          MA, Addison-Wesley, 2000. ISBN 0-201-61633-5), as amended
          by the 
          <emph>Unicode Standard Annex #27: Unicode 3.1</emph>(
          <loc href="http://www.unicode.org/reports/tr27/">
          http://www.unicode.org/reports/tr27</loc>) and the 
          <emph>Unicode Standard Annex #28: Unicode 3.2</emph>(
          <loc href="http://www.unicode.org/reports/tr28/">
          http://www.unicode.org/reports/tr28</loc>).</bibl>
        </blist>
      </div2>
      <div2 id="null">
        <head>Other References</head>
        <blist>
          <bibl id="Aho" key="Aho/Ullman">Aho, Alfred V., Ravi
          Sethi, and Jeffrey D. Ullman. 
          <titleref>Compilers: Principles, Techniques, and
          Tools</titleref>. Reading: Addison-Wesley, 1986, rpt.
          corr. 1988.</bibl>
          <bibl id="ABK"
          href="ftp://ftp.informatik.uni-freiburg.de/documents/papers/brueggem/habil.ps"
          key="Br&#195;&#188;ggemann-Klein">
          Br&#195;&#188;ggemann-Klein, Anne. 
          <titleref>Formal Models in Document
          Processing</titleref>. Habilitationsschrift. Faculty of
          Mathematics at the University of Freiburg, 1993.</bibl>
          <bibl id="ABKDW"
          key="Br&#195;&#188;ggemann-Klein and Wood">
          Br&#195;&#188;ggemann-Klein, Anne, and Derick Wood. 
          <titleref>Deterministic Regular Languages</titleref>.
          Universit&#195;&#164;t Freiburg, Institut f&#195;&#188;r
          Informatik, Bericht 38, Oktober 1991. Extended abstract
          in A. Finkel, M. Jantzen, Hrsg., STACS 1992, S. 173-184.
          Springer-Verlag, Berlin 1992. Lecture Notes in Computer
          Science 577. Full version titled 
          <titleref>One-Unambiguous Regular Languages</titleref>in
          Information and Computation 140 (2): 229-253, February
          1998.</bibl>
          <bibl id="Clark"
          href="http://www.w3.org/TR/NOTE-sgml-xml-971215"
          key="Clark">James Clark. 
          <titleref>Comparison of SGML and XML</titleref>.</bibl>
          <bibl id="IANA-LANGCODES"
          href="http://www.iana.org/assignments/language-subtag-registry"
          key="IANA-LANGCODES" diff="chg">
          <loc role="erratumref" href="E01" />(Internet Assigned
          Numbers Authority) 
          <titleref>Registry of Language Tags</titleref></bibl>
          <bibl id="RFC2141"
          href="http://www.ietf.org/rfc/rfc2141.txt"
          key="IETF RFC 2141">IETF (Internet Engineering Task
          Force). 
          <titleref>RFC 2141: URN Syntax</titleref>, ed. R. Moats.
          1997.</bibl>
          <bibl id="rfc2376"
          href="http://www.ietf.org/rfc/rfc3023.txt"
          key="IETF RFC 3023">IETF (Internet Engineering Task
          Force). 
          <titleref>RFC 3023: XML Media Types</titleref>. eds. M.
          Murata, S. St.Laurent, D. Kohn. 2001.</bibl>
          <bibl id="rfc2781"
          href="http://www.ietf.org/rfc/rfc2781.txt"
          key="IETF RFC 2781">IETF (Internet Engineering Task
          Force). 
          <titleref>RFC 2781: UTF-16, an encoding of ISO
          10646</titleref>, ed. P. Hoffman, F. Yergeau.
          2000.</bibl>
          <bibl id="ISO639" key="ISO 639">(International
          Organization for Standardization). 
          <titleref>ISO 639:1988 (E). Code for the representation
          of names of languages.</titleref>[Geneva]: International
          Organization for Standardization, 1988.</bibl>
          <bibl id="ISO3166" key="ISO 3166">(International
          Organization for Standardization). 
          <titleref>ISO 3166-1:1997 (E). Codes for the
          representation of names of countries and their
          subdivisions &#226;&#8364;&#8221; Part 1: Country
          codes</titleref>[Geneva]: International Organization for
          Standardization, 1997.</bibl>
          <bibl id="ISO8879" key="ISO 8879">ISO (International
          Organization for Standardization). 
          <titleref>ISO 8879:1986(E). Information processing
          &#226;&#8364;&#8221; Text and Office Systems
          &#226;&#8364;&#8221; Standard Generalized Markup Language
          (SGML).</titleref>First edition &#226;&#8364;&#8221;
          1986-10-15. [Geneva]: International Organization for
          Standardization, 1986.</bibl>
          <bibl id="ISO10744" key="ISO/IEC 10744">ISO
          (International Organization for Standardization). 
          <titleref>ISO/IEC 10744-1992 (E). Information technology
          &#226;&#8364;&#8221; Hypermedia/Time-based Structuring
          Language (HyTime).</titleref>[Geneva]: International
          Organization for Standardization, 1992. 
          <emph>Extended Facilities Annexe.</emph>[Geneva]:
          International Organization for Standardization,
          1996.</bibl>
          <bibl id="websgml"
          href="http://www.sgmlsource.com/8879/n0029.htm"
          key="WEBSGML">ISO (International Organization for
          Standardization). 
          <titleref>ISO 8879:1986 TC2. Information technology
          &#226;&#8364;&#8221; Document Description and Processing
          Languages</titleref>. [Geneva]: International
          Organization for Standardization, 1998.</bibl>
          <bibl id="xml-names"
          href="http://www.w3.org/TR/xml-names/" key="XML Names">
          Tim Bray, Dave Hollander, and Andrew Layman, editors. 
          <titleref>Namespaces in XML</titleref>. Textuality,
          Hewlett-Packard, and Microsoft. World Wide Web
          Consortium, 1999.</bibl>
        </blist>
      </div2>
    </div1>
    <div1 id="CharClasses">
      <head>Character Classes</head>
      <p diff="add">
      <loc role="erratumref" href="E09" />Because of changes to
      productions 
      <nt def="NT-NameStartChar">[4]</nt>and 
      <nt def="NT-Name">[5]</nt>, the productions in this Appendix
      are now orphaned and not used anymore in determining name
      characters. This Appendix may be removed in a future edition
      of this specification; other specifications that wish to
      refer to the productions herein should do so by means of a
      reference to the relevant production(s) in the 
      <loc href="http://www.w3.org/TR/2006/REC-xml-20060816/">
      Fourth Edition</loc>of this specification.</p>
      <p>Following the characteristics defined in the Unicode
      standard, characters are classed as base characters (among
      others, these contain the alphabetic characters of the Latin
      alphabet), ideographic characters, and combining characters
      (among others, this class contains most diacritics). Digits
      and extenders are also distinguished.</p>
      <scrap id="CHARACTERS" lang="ebnf">
        <head>Characters</head>
        <prodgroup pcw3="3" pcw4="15">
          <prod id="NT-Letter" num="84">
            <lhs>Letter</lhs>
            <rhs>
            <nt def="NT-BaseChar">BaseChar</nt>| 
            <nt def="NT-Ideographic">Ideographic</nt></rhs>
          </prod>
          <prod id="NT-BaseChar" num="85">
            <lhs>BaseChar</lhs>
            <rhs>[#x0041-#x005A] |&#194;&#160;[#x0061-#x007A]
            |&#194;&#160;[#x00C0-#x00D6]
            |&#194;&#160;[#x00D8-#x00F6]
            |&#194;&#160;[#x00F8-#x00FF]
            |&#194;&#160;[#x0100-#x0131]
            |&#194;&#160;[#x0134-#x013E]
            |&#194;&#160;[#x0141-#x0148]
            |&#194;&#160;[#x014A-#x017E]
            |&#194;&#160;[#x0180-#x01C3]
            |&#194;&#160;[#x01CD-#x01F0]
            |&#194;&#160;[#x01F4-#x01F5]
            |&#194;&#160;[#x01FA-#x0217]
            |&#194;&#160;[#x0250-#x02A8]
            |&#194;&#160;[#x02BB-#x02C1] |&#194;&#160;#x0386
            |&#194;&#160;[#x0388-#x038A] |&#194;&#160;#x038C
            |&#194;&#160;[#x038E-#x03A1]
            |&#194;&#160;[#x03A3-#x03CE]
            |&#194;&#160;[#x03D0-#x03D6] |&#194;&#160;#x03DA
            |&#194;&#160;#x03DC |&#194;&#160;#x03DE
            |&#194;&#160;#x03E0 |&#194;&#160;[#x03E2-#x03F3]
            |&#194;&#160;[#x0401-#x040C]
            |&#194;&#160;[#x040E-#x044F]
            |&#194;&#160;[#x0451-#x045C]
            |&#194;&#160;[#x045E-#x0481]
            |&#194;&#160;[#x0490-#x04C4]
            |&#194;&#160;[#x04C7-#x04C8]
            |&#194;&#160;[#x04CB-#x04CC]
            |&#194;&#160;[#x04D0-#x04EB]
            |&#194;&#160;[#x04EE-#x04F5]
            |&#194;&#160;[#x04F8-#x04F9]
            |&#194;&#160;[#x0531-#x0556] |&#194;&#160;#x0559
            |&#194;&#160;[#x0561-#x0586]
            |&#194;&#160;[#x05D0-#x05EA]
            |&#194;&#160;[#x05F0-#x05F2]
            |&#194;&#160;[#x0621-#x063A]
            |&#194;&#160;[#x0641-#x064A]
            |&#194;&#160;[#x0671-#x06B7]
            |&#194;&#160;[#x06BA-#x06BE]
            |&#194;&#160;[#x06C0-#x06CE]
            |&#194;&#160;[#x06D0-#x06D3] |&#194;&#160;#x06D5
            |&#194;&#160;[#x06E5-#x06E6]
            |&#194;&#160;[#x0905-#x0939] |&#194;&#160;#x093D
            |&#194;&#160;[#x0958-#x0961]
            |&#194;&#160;[#x0985-#x098C]
            |&#194;&#160;[#x098F-#x0990]
            |&#194;&#160;[#x0993-#x09A8]
            |&#194;&#160;[#x09AA-#x09B0] |&#194;&#160;#x09B2
            |&#194;&#160;[#x09B6-#x09B9]
            |&#194;&#160;[#x09DC-#x09DD]
            |&#194;&#160;[#x09DF-#x09E1]
            |&#194;&#160;[#x09F0-#x09F1]
            |&#194;&#160;[#x0A05-#x0A0A]
            |&#194;&#160;[#x0A0F-#x0A10]
            |&#194;&#160;[#x0A13-#x0A28]
            |&#194;&#160;[#x0A2A-#x0A30]
            |&#194;&#160;[#x0A32-#x0A33]
            |&#194;&#160;[#x0A35-#x0A36]
            |&#194;&#160;[#x0A38-#x0A39]
            |&#194;&#160;[#x0A59-#x0A5C] |&#194;&#160;#x0A5E
            |&#194;&#160;[#x0A72-#x0A74]
            |&#194;&#160;[#x0A85-#x0A8B] |&#194;&#160;#x0A8D
            |&#194;&#160;[#x0A8F-#x0A91]
            |&#194;&#160;[#x0A93-#x0AA8]
            |&#194;&#160;[#x0AAA-#x0AB0]
            |&#194;&#160;[#x0AB2-#x0AB3]
            |&#194;&#160;[#x0AB5-#x0AB9] |&#194;&#160;#x0ABD
            |&#194;&#160;#x0AE0 |&#194;&#160;[#x0B05-#x0B0C]
            |&#194;&#160;[#x0B0F-#x0B10]
            |&#194;&#160;[#x0B13-#x0B28]
            |&#194;&#160;[#x0B2A-#x0B30]
            |&#194;&#160;[#x0B32-#x0B33]
            |&#194;&#160;[#x0B36-#x0B39] |&#194;&#160;#x0B3D
            |&#194;&#160;[#x0B5C-#x0B5D]
            |&#194;&#160;[#x0B5F-#x0B61]
            |&#194;&#160;[#x0B85-#x0B8A]
            |&#194;&#160;[#x0B8E-#x0B90]
            |&#194;&#160;[#x0B92-#x0B95]
            |&#194;&#160;[#x0B99-#x0B9A] |&#194;&#160;#x0B9C
            |&#194;&#160;[#x0B9E-#x0B9F]
            |&#194;&#160;[#x0BA3-#x0BA4]
            |&#194;&#160;[#x0BA8-#x0BAA]
            |&#194;&#160;[#x0BAE-#x0BB5]
            |&#194;&#160;[#x0BB7-#x0BB9]
            |&#194;&#160;[#x0C05-#x0C0C]
            |&#194;&#160;[#x0C0E-#x0C10]
            |&#194;&#160;[#x0C12-#x0C28]
            |&#194;&#160;[#x0C2A-#x0C33]
            |&#194;&#160;[#x0C35-#x0C39]
            |&#194;&#160;[#x0C60-#x0C61]
            |&#194;&#160;[#x0C85-#x0C8C]
            |&#194;&#160;[#x0C8E-#x0C90]
            |&#194;&#160;[#x0C92-#x0CA8]
            |&#194;&#160;[#x0CAA-#x0CB3]
            |&#194;&#160;[#x0CB5-#x0CB9] |&#194;&#160;#x0CDE
            |&#194;&#160;[#x0CE0-#x0CE1]
            |&#194;&#160;[#x0D05-#x0D0C]
            |&#194;&#160;[#x0D0E-#x0D10]
            |&#194;&#160;[#x0D12-#x0D28]
            |&#194;&#160;[#x0D2A-#x0D39]
            |&#194;&#160;[#x0D60-#x0D61]
            |&#194;&#160;[#x0E01-#x0E2E] |&#194;&#160;#x0E30
            |&#194;&#160;[#x0E32-#x0E33]
            |&#194;&#160;[#x0E40-#x0E45]
            |&#194;&#160;[#x0E81-#x0E82] |&#194;&#160;#x0E84
            |&#194;&#160;[#x0E87-#x0E88] |&#194;&#160;#x0E8A
            |&#194;&#160;#x0E8D |&#194;&#160;[#x0E94-#x0E97]
            |&#194;&#160;[#x0E99-#x0E9F]
            |&#194;&#160;[#x0EA1-#x0EA3] |&#194;&#160;#x0EA5
            |&#194;&#160;#x0EA7 |&#194;&#160;[#x0EAA-#x0EAB]
            |&#194;&#160;[#x0EAD-#x0EAE] |&#194;&#160;#x0EB0
            |&#194;&#160;[#x0EB2-#x0EB3] |&#194;&#160;#x0EBD
            |&#194;&#160;[#x0EC0-#x0EC4]
            |&#194;&#160;[#x0F40-#x0F47]
            |&#194;&#160;[#x0F49-#x0F69]
            |&#194;&#160;[#x10A0-#x10C5]
            |&#194;&#160;[#x10D0-#x10F6] |&#194;&#160;#x1100
            |&#194;&#160;[#x1102-#x1103]
            |&#194;&#160;[#x1105-#x1107] |&#194;&#160;#x1109
            |&#194;&#160;[#x110B-#x110C]
            |&#194;&#160;[#x110E-#x1112] |&#194;&#160;#x113C
            |&#194;&#160;#x113E |&#194;&#160;#x1140
            |&#194;&#160;#x114C |&#194;&#160;#x114E
            |&#194;&#160;#x1150 |&#194;&#160;[#x1154-#x1155]
            |&#194;&#160;#x1159 |&#194;&#160;[#x115F-#x1161]
            |&#194;&#160;#x1163 |&#194;&#160;#x1165
            |&#194;&#160;#x1167 |&#194;&#160;#x1169
            |&#194;&#160;[#x116D-#x116E]
            |&#194;&#160;[#x1172-#x1173] |&#194;&#160;#x1175
            |&#194;&#160;#x119E |&#194;&#160;#x11A8
            |&#194;&#160;#x11AB |&#194;&#160;[#x11AE-#x11AF]
            |&#194;&#160;[#x11B7-#x11B8] |&#194;&#160;#x11BA
            |&#194;&#160;[#x11BC-#x11C2] |&#194;&#160;#x11EB
            |&#194;&#160;#x11F0 |&#194;&#160;#x11F9
            |&#194;&#160;[#x1E00-#x1E9B]
            |&#194;&#160;[#x1EA0-#x1EF9]
            |&#194;&#160;[#x1F00-#x1F15]
            |&#194;&#160;[#x1F18-#x1F1D]
            |&#194;&#160;[#x1F20-#x1F45]
            |&#194;&#160;[#x1F48-#x1F4D]
            |&#194;&#160;[#x1F50-#x1F57] |&#194;&#160;#x1F59
            |&#194;&#160;#x1F5B |&#194;&#160;#x1F5D
            |&#194;&#160;[#x1F5F-#x1F7D]
            |&#194;&#160;[#x1F80-#x1FB4]
            |&#194;&#160;[#x1FB6-#x1FBC] |&#194;&#160;#x1FBE
            |&#194;&#160;[#x1FC2-#x1FC4]
            |&#194;&#160;[#x1FC6-#x1FCC]
            |&#194;&#160;[#x1FD0-#x1FD3]
            |&#194;&#160;[#x1FD6-#x1FDB]
            |&#194;&#160;[#x1FE0-#x1FEC]
            |&#194;&#160;[#x1FF2-#x1FF4]
            |&#194;&#160;[#x1FF6-#x1FFC] |&#194;&#160;#x2126
            |&#194;&#160;[#x212A-#x212B] |&#194;&#160;#x212E
            |&#194;&#160;[#x2180-#x2182]
            |&#194;&#160;[#x3041-#x3094]
            |&#194;&#160;[#x30A1-#x30FA]
            |&#194;&#160;[#x3105-#x312C]
            |&#194;&#160;[#xAC00-#xD7A3]</rhs>
          </prod>
          <prod id="NT-Ideographic" num="86">
            <lhs>Ideographic</lhs>
            <rhs>[#x4E00-#x9FA5] |&#194;&#160;#x3007
            |&#194;&#160;[#x3021-#x3029]</rhs>
          </prod>
          <prod id="NT-CombiningChar" num="87">
            <lhs>CombiningChar</lhs>
            <rhs>[#x0300-#x0345] |&#194;&#160;[#x0360-#x0361]
            |&#194;&#160;[#x0483-#x0486]
            |&#194;&#160;[#x0591-#x05A1]
            |&#194;&#160;[#x05A3-#x05B9]
            |&#194;&#160;[#x05BB-#x05BD] |&#194;&#160;#x05BF
            |&#194;&#160;[#x05C1-#x05C2] |&#194;&#160;#x05C4
            |&#194;&#160;[#x064B-#x0652] |&#194;&#160;#x0670
            |&#194;&#160;[#x06D6-#x06DC]
            |&#194;&#160;[#x06DD-#x06DF]
            |&#194;&#160;[#x06E0-#x06E4]
            |&#194;&#160;[#x06E7-#x06E8]
            |&#194;&#160;[#x06EA-#x06ED]
            |&#194;&#160;[#x0901-#x0903] |&#194;&#160;#x093C
            |&#194;&#160;[#x093E-#x094C] |&#194;&#160;#x094D
            |&#194;&#160;[#x0951-#x0954]
            |&#194;&#160;[#x0962-#x0963]
            |&#194;&#160;[#x0981-#x0983] |&#194;&#160;#x09BC
            |&#194;&#160;#x09BE |&#194;&#160;#x09BF
            |&#194;&#160;[#x09C0-#x09C4]
            |&#194;&#160;[#x09C7-#x09C8]
            |&#194;&#160;[#x09CB-#x09CD] |&#194;&#160;#x09D7
            |&#194;&#160;[#x09E2-#x09E3] |&#194;&#160;#x0A02
            |&#194;&#160;#x0A3C |&#194;&#160;#x0A3E
            |&#194;&#160;#x0A3F |&#194;&#160;[#x0A40-#x0A42]
            |&#194;&#160;[#x0A47-#x0A48]
            |&#194;&#160;[#x0A4B-#x0A4D]
            |&#194;&#160;[#x0A70-#x0A71]
            |&#194;&#160;[#x0A81-#x0A83] |&#194;&#160;#x0ABC
            |&#194;&#160;[#x0ABE-#x0AC5]
            |&#194;&#160;[#x0AC7-#x0AC9]
            |&#194;&#160;[#x0ACB-#x0ACD]
            |&#194;&#160;[#x0B01-#x0B03] |&#194;&#160;#x0B3C
            |&#194;&#160;[#x0B3E-#x0B43]
            |&#194;&#160;[#x0B47-#x0B48]
            |&#194;&#160;[#x0B4B-#x0B4D]
            |&#194;&#160;[#x0B56-#x0B57]
            |&#194;&#160;[#x0B82-#x0B83]
            |&#194;&#160;[#x0BBE-#x0BC2]
            |&#194;&#160;[#x0BC6-#x0BC8]
            |&#194;&#160;[#x0BCA-#x0BCD] |&#194;&#160;#x0BD7
            |&#194;&#160;[#x0C01-#x0C03]
            |&#194;&#160;[#x0C3E-#x0C44]
            |&#194;&#160;[#x0C46-#x0C48]
            |&#194;&#160;[#x0C4A-#x0C4D]
            |&#194;&#160;[#x0C55-#x0C56]
            |&#194;&#160;[#x0C82-#x0C83]
            |&#194;&#160;[#x0CBE-#x0CC4]
            |&#194;&#160;[#x0CC6-#x0CC8]
            |&#194;&#160;[#x0CCA-#x0CCD]
            |&#194;&#160;[#x0CD5-#x0CD6]
            |&#194;&#160;[#x0D02-#x0D03]
            |&#194;&#160;[#x0D3E-#x0D43]
            |&#194;&#160;[#x0D46-#x0D48]
            |&#194;&#160;[#x0D4A-#x0D4D] |&#194;&#160;#x0D57
            |&#194;&#160;#x0E31 |&#194;&#160;[#x0E34-#x0E3A]
            |&#194;&#160;[#x0E47-#x0E4E] |&#194;&#160;#x0EB1
            |&#194;&#160;[#x0EB4-#x0EB9]
            |&#194;&#160;[#x0EBB-#x0EBC]
            |&#194;&#160;[#x0EC8-#x0ECD]
            |&#194;&#160;[#x0F18-#x0F19] |&#194;&#160;#x0F35
            |&#194;&#160;#x0F37 |&#194;&#160;#x0F39
            |&#194;&#160;#x0F3E |&#194;&#160;#x0F3F
            |&#194;&#160;[#x0F71-#x0F84]
            |&#194;&#160;[#x0F86-#x0F8B]
            |&#194;&#160;[#x0F90-#x0F95] |&#194;&#160;#x0F97
            |&#194;&#160;[#x0F99-#x0FAD]
            |&#194;&#160;[#x0FB1-#x0FB7] |&#194;&#160;#x0FB9
            |&#194;&#160;[#x20D0-#x20DC] |&#194;&#160;#x20E1
            |&#194;&#160;[#x302A-#x302F] |&#194;&#160;#x3099
            |&#194;&#160;#x309A</rhs>
          </prod>
          <prod id="NT-Digit" num="88">
            <lhs>Digit</lhs>
            <rhs>[#x0030-#x0039] |&#194;&#160;[#x0660-#x0669]
            |&#194;&#160;[#x06F0-#x06F9]
            |&#194;&#160;[#x0966-#x096F]
            |&#194;&#160;[#x09E6-#x09EF]
            |&#194;&#160;[#x0A66-#x0A6F]
            |&#194;&#160;[#x0AE6-#x0AEF]
            |&#194;&#160;[#x0B66-#x0B6F]
            |&#194;&#160;[#x0BE7-#x0BEF]
            |&#194;&#160;[#x0C66-#x0C6F]
            |&#194;&#160;[#x0CE6-#x0CEF]
            |&#194;&#160;[#x0D66-#x0D6F]
            |&#194;&#160;[#x0E50-#x0E59]
            |&#194;&#160;[#x0ED0-#x0ED9]
            |&#194;&#160;[#x0F20-#x0F29]</rhs>
          </prod>
          <prod id="NT-Extender" num="89">
            <lhs>Extender</lhs>
            <rhs>#x00B7 |&#194;&#160;#x02D0 |&#194;&#160;#x02D1
            |&#194;&#160;#x0387 |&#194;&#160;#x0640
            |&#194;&#160;#x0E46 |&#194;&#160;#x0EC6
            |&#194;&#160;#x3005 |&#194;&#160;[#x3031-#x3035]
            |&#194;&#160;[#x309D-#x309E]
            |&#194;&#160;[#x30FC-#x30FE]</rhs>
          </prod>
        </prodgroup>
      </scrap>
      <p>The character classes defined here can be derived from the
      Unicode 2.0 character database as follows:</p>
      <ulist>
        <item>
          <p>Name start characters must have one of the categories
          Ll, Lu, Lo, Lt, Nl.</p>
        </item>
        <item>
          <p>Name characters other than Name-start characters must
          have one of the categories Mc, Me, Mn, Lm, or Nd.</p>
        </item>
        <item>
          <p>Characters in the compatibility area (i.e. with
          character code greater than #xF900 and less than #xFFFE)
          are not allowed in XML names.</p>
        </item>
        <item>
          <p>Characters which have a font or compatibility
          decomposition (i.e. those with a 
          <quote>compatibility formatting tag</quote>in field 5 of
          the database -- marked by field 5 beginning with a 
          <quote>&lt;</quote>) are not allowed.</p>
        </item>
        <item>
          <p>The following characters are treated as name-start
          characters rather than name characters, because the
          property file classifies them as Alphabetic:
          [#x02BB-#x02C1], #x0559, #x06E5, #x06E6.</p>
        </item>
        <item>
          <p>Characters #x20DD-#x20E0 are excluded (in accordance
          with Unicode 2.0, section 5.14).</p>
        </item>
        <item>
          <p>Character #x00B7 is classified as an extender, because
          the property list so identifies it.</p>
        </item>
        <item>
          <p>Character #x0387 is added as a name character, because
          #x00B7 is its canonical equivalent.</p>
        </item>
        <item>
          <p>Characters ':' and '_' are allowed as name-start
          characters.</p>
        </item>
        <item>
          <p>Characters '-' and '.' are allowed as name
          characters.</p>
        </item>
      </ulist>
    </div1>
    <inform-div1 id="sec-xml-and-sgml">
      <head>XML and SGML</head>
      <p>XML is designed to be a subset of SGML, in that every XML
      document should also be a conforming SGML document. For a
      detailed comparison of the additional restrictions that XML
      places on documents beyond those of SGML, see 
      <bibref ref="Clark" />.</p>
    </inform-div1>
    <inform-div1 id="sec-entexpand">
      <head>Expansion of Entity and Character References</head>
      <p>This appendix contains some examples illustrating the
      sequence of entity- and character-reference recognition and
      expansion, as specified in 
      <specref ref="entproc" />.</p>
      <p>If the DTD contains the declaration</p>
      <eg>&lt;!ENTITY example "&lt;p&gt;An ampersand
      (&amp;#38;#38;) may be escaped numerically
      (&amp;#38;#38;#38;) or with a general entity
      (&amp;amp;amp;).&lt;/p&gt;" &gt;</eg>
      <p>then the XML processor will recognize the character
      references when it parses the entity declaration, and resolve
      them before storing the following string as the value of the
      entity 
      <quote>
        <code>example</code>
      </quote>:</p>
      <eg>&lt;p&gt;An ampersand (&amp;#38;) may be escaped
      numerically (&amp;#38;#38;) or with a general entity
      (&amp;amp;amp;).&lt;/p&gt;</eg>
      <p>A reference in the document to 
      <quote>
        <code>&amp;example;</code>
      </quote>will cause the text to be reparsed, at which time the
      start- and end-tags of the 
      <el>p</el>element will be recognized and the three references
      will be recognized and expanded, resulting in a 
      <el>p</el>element with the following content (all data, no
      delimiters or markup):</p>
      <eg>An ampersand (&amp;) may be escaped numerically
      (&amp;#38;) or with a general entity (&amp;amp;).</eg>
      <p>A more complex example will illustrate the rules and their
      effects fully. In the following example, the line numbers are
      solely for reference.</p>
      <eg>1 &lt;?xml version='1.0'?&gt; 2 &lt;!DOCTYPE test [ 3
      &lt;!ELEMENT test (#PCDATA) &gt; 4 &lt;!ENTITY % xx
      '&amp;#37;zz;'&gt; 5 &lt;!ENTITY % zz '&amp;#60;!ENTITY
      tricky "error-prone" &gt;' &gt; 6 %xx; 7 ]&gt; 8
      &lt;test&gt;This sample shows a &amp;tricky;
      method.&lt;/test&gt;</eg>
      <p>This produces the following:</p>
      <ulist spacing="compact">
        <item>
          <p>in line 4, the reference to character 37 is expanded
          immediately, and the parameter entity 
          <quote>
            <code>xx</code>
          </quote>is stored in the symbol table with the value 
          <quote>
            <code>%zz;</code>
          </quote>. Since the replacement text is not rescanned,
          the reference to parameter entity 
          <quote>
            <code>zz</code>
          </quote>is not recognized. (And it would be an error if
          it were, since 
          <quote>
            <code>zz</code>
          </quote>is not yet declared.)</p>
        </item>
        <item>
          <p>in line 5, the character reference 
          <quote>
            <code>&amp;#60;</code>
          </quote>is expanded immediately and the parameter entity 
          <quote>
            <code>zz</code>
          </quote>is stored with the replacement text 
          <quote>
            <code>&lt;!ENTITY tricky "error-prone" &gt;</code>
          </quote>, which is a well-formed entity declaration.</p>
        </item>
        <item>
          <p>in line 6, the reference to 
          <quote>
            <code>xx</code>
          </quote>is recognized, and the replacement text of 
          <quote>
            <code>xx</code>
          </quote>(namely 
          <quote>
            <code>%zz;</code>
          </quote>) is parsed. The reference to 
          <quote>
            <code>zz</code>
          </quote>is recognized in its turn, and its replacement
          text (
          <quote>
            <code>&lt;!ENTITY tricky "error-prone" &gt;</code>
          </quote>) is parsed. The general entity 
          <quote>
            <code>tricky</code>
          </quote>has now been declared, with the replacement text 
          <quote>
            <code>error-prone</code>
          </quote>.</p>
        </item>
        <item>
          <p>in line 8, the reference to the general entity 
          <quote>
            <code>tricky</code>
          </quote>is recognized, and it is expanded, so the full
          content of the 
          <el>test</el>element is the self-describing (and
          ungrammatical) string 
          <emph>This sample shows a error-prone method.</emph></p>
        </item>
      </ulist>
      <p diff="add">
      <loc role="erratumref" href="E07" />In the following
      example</p>
      <eg diff="add">
      <loc role="erratumref" href="E07" />&lt;!DOCTYPE foo [
      &lt;!ENTITY x "&amp;lt;"&gt; ]&gt; &lt;foo
      attr="&amp;x;"/&gt;</eg>
      <p diff="add">
      <loc role="erratumref" href="E07" />the replacement text of x
      is the four characters "&amp;lt;" because references to
      general entities in entity values are 
      <titleref href="#bypass">bypassed</titleref>. The replacement
      text of lt is a character reference to the less-than
      character, for example the five characters "&amp;#60;" (see 
      <specref ref="sec-predefined-ent" />). Since neither of these
      contains a less-than character the result is well-formed.</p>
      <p diff="add">
      <loc role="erratumref" href="E07" />If the definition of x
      had been</p>
      <eg diff="add">
      <loc role="erratumref" href="E07" />&lt;!ENTITY x
      "&amp;#60;"&gt;</eg>
      <p diff="add">
      <loc role="erratumref" href="E07" />then the document would
      not have been well-formed, because the replacement text of x
      would be the single character "&lt;" which is not permitted
      in attribute values (see 
      <titleref href="#CleanAttrVals">WFC: No &lt; in Attribute
      Values</titleref>).</p>
    </inform-div1>
    <inform-div1 id="determinism">
      <head>Deterministic Content Models</head>
      <p>As noted in 
      <specref ref="sec-element-content" />, it is required that
      content models in element type declarations be deterministic.
      This requirement is 
      <termref def="dt-compat">for compatibility</termref>with SGML
      (which calls deterministic content models 
      <quote>unambiguous</quote>); XML processors built using SGML
      systems may flag non-deterministic content models as
      errors.</p>
      <p>For example, the content model 
      <code>((b, c) | (b, d))</code>is non-deterministic, because
      given an initial 
      <el>b</el>the XML processor cannot know which 
      <el>b</el>in the model is being matched without looking ahead
      to see which element follows the 
      <el>b</el>. In this case, the two references to 
      <el>b</el>can be collapsed into a single reference, making
      the model read 
      <code>(b, (c | d))</code>. An initial 
      <el>b</el>now clearly matches only a single name in the
      content model. The processor doesn't need to look ahead to
      see what follows; either 
      <el>c</el>or 
      <el>d</el>would be accepted.</p>
      <p>More formally: a finite state automaton may be constructed
      from the content model using the standard algorithms, e.g.
      algorithm 3.5 in section 3.9 of Aho, Sethi, and Ullman 
      <bibref ref="Aho" />. In many such algorithms, a follow set
      is constructed for each position in the regular expression
      (i.e., each leaf node in the syntax tree for the regular
      expression); if any position has a follow set in which more
      than one following position is labeled with the same element
      type name, then the content model is in error and may be
      reported as an error.</p>
      <p>Algorithms exist which allow many but not all
      non-deterministic content models to be reduced automatically
      to equivalent deterministic models; see
      Br&#195;&#188;ggemann-Klein 1991 
      <bibref ref="ABK" />.</p>
    </inform-div1>
    <inform-div1 id="sec-guessing">
      <head>Autodetection of Character Encodings</head>
      <p>The XML encoding declaration functions as an internal
      label on each entity, indicating which character encoding is
      in use. Before an XML processor can read the internal label,
      however, it apparently has to know what character encoding is
      in use&#226;&#8364;&#8221;which is what the internal label is
      trying to indicate. In the general case, this is a hopeless
      situation. It is not entirely hopeless in XML, however,
      because XML limits the general case in two ways: each
      implementation is assumed to support only a finite set of
      character encodings, and the XML encoding declaration is
      restricted in position and content in order to make it
      feasible to autodetect the character encoding in use in each
      entity in normal cases. Also, in many cases other sources of
      information are available in addition to the XML data stream
      itself. Two cases may be distinguished, depending on whether
      the XML entity is presented to the processor without, or
      with, any accompanying (external) information. We 
      <phrase diff="add">
      <loc role="erratumref" href="E05" />will</phrase>consider 
      <phrase diff="del">
      <loc role="erratumref" href="E05" />the first case
      first.</phrase>
      <phrase diff="add">
      <loc role="erratumref" href="E05" />these cases in
      turn.</phrase></p>
      <div2 id="sec-guessing-no-ext-info">
        <head>Detection Without External Encoding
        Information</head>
        <p>Because each XML entity not accompanied by external
        encoding information and not in UTF-8 or UTF-16 encoding
        must begin with an XML encoding declaration, in which the
        first characters must be '
        <code>&lt;?xml</code>', any conforming processor can
        detect, after two to four octets of input, which of the
        following cases apply. In reading this list, it may help to
        know that in UCS-4, '&lt;' is 
        <quote>
          <code>#x0000003C</code>
        </quote>and '?' is 
        <quote>
          <code>#x0000003F</code>
        </quote>, and the Byte Order Mark required of UTF-16 data
        streams is 
        <quote>
          <code>#xFEFF</code>
        </quote>. The notation 
        <var>##</var>is used to denote any byte value except that
        two consecutive 
        <var>##</var>s cannot be both 00.</p>
        <p>With a Byte Order Mark:</p>
        <table border="1" frame="border">
          <tbody>
            <tr>
              <td>
                <code>00 00 FE FF</code>
              </td>
              <td>UCS-4, big-endian machine (1234 order)</td>
            </tr>
            <tr>
              <td>
                <code>FF FE 00 00</code>
              </td>
              <td>UCS-4, little-endian machine (4321 order)</td>
            </tr>
            <tr>
              <td>
                <code>00 00 FF FE</code>
              </td>
              <td>UCS-4, unusual octet order (2143)</td>
            </tr>
            <tr>
              <td>
                <code>FE FF 00 00</code>
              </td>
              <td>UCS-4, unusual octet order (3412)</td>
            </tr>
            <tr>
              <td>
                <code>FE FF ## ##</code>
              </td>
              <td>UTF-16, big-endian</td>
            </tr>
            <tr>
              <td>
                <code>FF FE ## ##</code>
              </td>
              <td>UTF-16, little-endian</td>
            </tr>
            <tr>
              <td>
                <code>EF BB BF</code>
              </td>
              <td>UTF-8</td>
            </tr>
          </tbody>
        </table>
        <p>Without a Byte Order Mark:</p>
        <table border="1" frame="border">
          <tbody>
            <tr>
              <td>
                <code>
                00&#194;&#160;00&#194;&#160;00&#194;&#160;3C</code>
              </td>
              <td rowspan="4">UCS-4 or other encoding with a 32-bit
              code unit and ASCII characters encoded as ASCII
              values, in respectively big-endian (1234),
              little-endian (4321) and two unusual byte orders
              (2143 and 3412). The encoding declaration must be
              read to determine which of UCS-4 or other supported
              32-bit encodings applies.</td>
            </tr>
            <tr>
              <td>
                <code>3C 00 00 00</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>00 00 3C 00</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>00 3C 00 00</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>00 3C 00 3F</code>
              </td>
              <td>UTF-16BE or big-endian ISO-10646-UCS-2 or other
              encoding with a 16-bit code unit in big-endian order
              and ASCII characters encoded as ASCII values (the
              encoding declaration must be read to determine
              which)</td>
            </tr>
            <tr>
              <td>
                <code>3C 00 3F 00</code>
              </td>
              <td>UTF-16LE or little-endian ISO-10646-UCS-2 or
              other encoding with a 16-bit code unit in
              little-endian order and ASCII characters encoded as
              ASCII values (the encoding declaration must be read
              to determine which)</td>
            </tr>
            <tr>
              <td>
                <code>3C 3F 78 6D</code>
              </td>
              <td>UTF-8, ISO 646, ASCII, some part of ISO 8859,
              Shift-JIS, EUC, or any other 7-bit, 8-bit, or
              mixed-width encoding which ensures that the
              characters of ASCII have their normal positions,
              width, and values; the actual encoding declaration
              must be read to detect which of these applies, but
              since all of these encodings use the same bit
              patterns for the relevant ASCII characters, the
              encoding declaration itself may be read reliably</td>
            </tr>
            <tr>
              <td>
                <code>4C 6F A7 94</code>
              </td>
              <td>EBCDIC (in some flavor; the full encoding
              declaration must be read to tell which code page is
              in use)</td>
            </tr>
            <tr>
              <td>Other</td>
              <td>UTF-8 without an encoding declaration, or else
              the data stream is mislabeled (lacking a required
              encoding declaration), corrupt, fragmentary, or
              enclosed in a wrapper of some kind</td>
            </tr>
          </tbody>
        </table>
        <note>
          <p>In cases above which do not require reading the
          encoding declaration to determine the encoding, section
          4.3.3 still requires that the encoding declaration, if
          present, be read and that the encoding name be checked to
          match the actual encoding of the entity. Also, it is
          possible that new character encodings will be invented
          that will make it necessary to use the encoding
          declaration to determine the encoding, in cases where
          this is not required at present.</p>
        </note>
        <p>This level of autodetection is enough to read the XML
        encoding declaration and parse the character-encoding
        identifier, which is still necessary to distinguish the
        individual members of each family of encodings (e.g. to
        tell UTF-8 from 8859, and the parts of 8859 from each
        other, or to distinguish the specific EBCDIC code page in
        use, and so on).</p>
        <p>Because the contents of the encoding declaration are
        restricted to characters from the ASCII repertoire (however
        encoded), a processor can reliably read the entire encoding
        declaration as soon as it has detected which family of
        encodings is in use. Since in practice, all widely used
        character encodings fall into one of the categories above,
        the XML encoding declaration allows reasonably reliable
        in-band labeling of character encodings, even when external
        sources of information at the operating-system or
        transport-protocol level are unreliable. Character
        encodings such as UTF-7 that make overloaded usage of
        ASCII-valued bytes may fail to be reliably detected.</p>
        <p>Once the processor has detected the character encoding
        in use, it can act appropriately, whether by invoking a
        separate input routine for each case, or by calling the
        proper conversion function on each character of input.</p>
        <p>Like any self-labeling system, the XML encoding
        declaration will not work if any software changes the
        entity's character set or encoding without updating the
        encoding declaration. Implementors of character-encoding
        routines should be careful to ensure the accuracy of the
        internal and external information used to label the
        entity.</p>
      </div2>
      <div2 id="sec-guessing-with-ext-info">
        <head>Priorities in the Presence of External Encoding
        Information</head>
        <p>The second possible case occurs when the XML entity is
        accompanied by encoding information, as in some file
        systems and some network protocols. When multiple sources
        of information are available, their relative priority and
        the preferred method of handling conflict should be
        specified as part of the higher-level protocol used to
        deliver XML. In particular, please refer to 
        <bibref ref="rfc2376" />or its successor, which defines the
        
        <code>text/xml</code>and 
        <code>application/xml</code>MIME types and provides some
        useful guidance. In the interests of interoperability,
        however, the following rule is recommended.</p>
        <ulist>
          <item>
            <p>If an XML entity is in a file, the Byte-Order Mark
            and encoding declaration are used (if present) to
            determine the character encoding.</p>
          </item>
        </ulist>
      </div2>
    </inform-div1>
    <inform-div1 id="sec-xml-wg">
      <head>W3C XML Working Group</head>
      <p>This specification was prepared and approved for
      publication by the W3C XML Working Group (WG). WG approval of
      this specification does not necessarily imply that all WG
      members voted for its approval. The current and former
      participants of the XML WG are:</p>
      <orglist>
        <member>
          <name>Jon Bosak</name>
          <affiliation>Sun</affiliation>
          <role>Chair</role>
        </member>
        <member>
          <name>James Clark</name>
          <role>Technical Lead</role>
        </member>
        <member>
          <name>Tim Bray</name>
          <affiliation>Textuality and Netscape</affiliation>
          <role>XML Co-editor</role>
        </member>
        <member>
          <name>Jean Paoli</name>
          <affiliation>Microsoft</affiliation>
          <role>XML Co-editor</role>
        </member>
        <member>
          <name>C. M. Sperberg-McQueen</name>
          <affiliation>U. of Ill.</affiliation>
          <role>XML Co-editor</role>
        </member>
        <member>
          <name>Dan Connolly</name>
          <affiliation>W3C</affiliation>
          <role>W3C Liaison</role>
        </member>
        <member>
          <name>Paula Angerstein</name>
          <affiliation>Texcel</affiliation>
        </member>
        <member>
          <name>Steve DeRose</name>
          <affiliation>INSO</affiliation>
        </member>
        <member>
          <name>Dave Hollander</name>
          <affiliation>HP</affiliation>
        </member>
        <member>
          <name>Eliot Kimber</name>
          <affiliation>ISOGEN</affiliation>
        </member>
        <member>
          <name>Eve Maler</name>
          <affiliation>ArborText</affiliation>
        </member>
        <member>
          <name>Tom Magliery</name>
          <affiliation>NCSA</affiliation>
        </member>
        <member>
          <name>Murray Maloney</name>
          <affiliation>SoftQuad, Grif SA, Muzmo and Veo
          Systems</affiliation>
        </member>
        <member>
          <name>MURATA Makoto (FAMILY Given)</name>
          <affiliation>Fuji Xerox Information Systems</affiliation>
        </member>
        <member>
          <name>Joel Nava</name>
          <affiliation>Adobe</affiliation>
        </member>
        <member>
          <name>Conleth O'Connell</name>
          <affiliation>Vignette</affiliation>
        </member>
        <member>
          <name>Peter Sharpe</name>
          <affiliation>SoftQuad</affiliation>
        </member>
        <member>
          <name>John Tigue</name>
          <affiliation>DataChannel</affiliation>
        </member>
      </orglist>
    </inform-div1>
    <inform-div1 id="sec-core-wg">
      <head>W3C XML Core Working Group</head>
      <p>The 
      <phrase diff="chg">fifth</phrase>edition of this
      specification was prepared by the W3C XML Core Working Group
      (WG). The participants in the WG at the time of publication
      of this edition were:</p>
      <orglist>
        <member>
          <name>John Cowan</name>
          <affiliation>Google</affiliation>
        </member>
        <member>
          <name>Andrew Fang</name>
          <affiliation>PTC-Arbortext</affiliation>
        </member>
        <member>
          <name>Paul Grosso</name>
          <affiliation>PTC-Arbortext</affiliation>
          <role>Co-Chair</role>
        </member>
        <member>
          <name>Konrad Lanz</name>
          <affiliation>A-SIT</affiliation>
        </member>
        <member>
          <name>Glenn Marcy</name>
          <affiliation>IBM</affiliation>
        </member>
        <member>
          <name>Henry Thompson</name>
          <affiliation>W3C</affiliation>
          <role>Staff Contact</role>
        </member>
        <member>
          <name>Richard Tobin</name>
          <affiliation>University of Edinburgh</affiliation>
        </member>
        <member>
          <name>Daniel Veillard</name>
        </member>
        <member>
          <name>Norman Walsh</name>
          <affiliation>Mark Logic</affiliation>
          <role>Co-Chair</role>
        </member>
        <member>
          <name>Fran&#195;&#167;ois Yergeau</name>
        </member>
      </orglist>
    </inform-div1>
    <inform-div1 id="prod-notes">
      <head>Production Notes</head>
      <p diff="chg">This edition was encoded in a slightly modified
      version of the 
      <loc href="http://www.w3.org/2002/xmlspec/dtd/2.10/xmlspec.dtd">
      XMLspec DTD, v2.10</loc>. The XHTML versions were produced
      with a combination of the 
      <loc href="http://www.w3.org/2002/xmlspec/xhtml/1.13/xmlspec.xsl">
      xmlspec.xsl</loc>, 
      <loc href="http://www.w3.org/2002/xmlspec/xhtml/1.13/diffspec.xsl">
      diffspec.xsl</loc>, and 
      <loc href="REC-xml.xsl">REC-xml.xsl</loc>XSLT
      stylesheets.</p>
    </inform-div1>
    <inform-div1 id="sec-suggested-names" diff="add">
      <head>
      <loc role="erratumref" href="E09" />Suggestions for XML
      Names</head>
      <p>
      <loc role="erratumref" href="E09" />The following suggestions
      define what is believed to be best practice in the
      construction of XML names used as element names, attribute
      names, processing instruction targets, entity names, notation
      names, and the values of attributes of type ID, and are
      intended as guidance for document authors and schema
      designers. All references to Unicode are understood with
      respect to a particular version of the Unicode Standard
      greater than or equal to 5.0; which version should be used is
      left to the discretion of the document author or schema
      designer.</p>
      <p>The first two suggestions are directly derived from the
      rules given for identifiers in Standard Annex #31 (UAX #31)
      of the Unicode Standard, version 5.0 
      <bibref ref="Unicode" />, and exclude all control characters,
      enclosing nonspacing marks, non-decimal numbers, private-use
      characters, punctuation characters (with the noted
      exceptions), symbol characters, unassigned codepoints, and
      white space characters. The other suggestions are mostly
      derived from Appendix B in previous editions of this
      specification.</p>
      <olist>
        <item>
          <p>The first character of any name should have a Unicode
          property of ID_Start, or else be '_' #x5F.</p>
        </item>
        <item>
          <p>Characters other than the first should have a Unicode
          property of ID_Continue, or be one of the characters
          listed in the table entitled "Characters for Natural
          Language Identifiers" in UAX #31, with the exception of
          "'" #x27 and "&#226;&#8364;&#8482;" #x2019.</p>
        </item>
        <item>
          <p>Characters in names should be expressed using
          Normalization Form C as defined in 
          <bibref ref="unipart15" />.</p>
        </item>
        <item>
          <p>Ideographic characters which have a canonical
          decomposition (including those in the ranges
          [#xF900-#xFAFF] and [#x2F800-#x2FFFD], with 12
          exceptions) should not be used in names.</p>
        </item>
        <item>
          <p>Characters which have a compatibility decomposition
          (those with a "compatibility formatting tag" in field 5
          of the Unicode Character Database -- marked by field 5
          beginning with a "&lt;") should not be used in names.
          This suggestion does not apply to characters which
          despite their compatibility decompositions are in regular
          use in their scripts, for example #x0E33 THAI CHARACTER
          SARA AM or #x0EB3 LAO CHARACTER AM.</p>
        </item>
        <item>
          <p>Combining characters meant for use with symbols only
          (including those in the ranges [#x20D0-#x20EF] and
          [#x1D165-#x1D1AD]) should not be used in names.</p>
        </item>
        <item>
          <p>The interlinear annotation characters
          ([#xFFF9-#xFFFB]) should not be used in names.</p>
        </item>
        <item>
          <p>Variation selector characters should not be used in
          names.</p>
        </item>
        <item>
          <p>Names which are nonsensical, unpronounceable, hard to
          read, or easily confusable with other names should not be
          employed.</p>
        </item>
      </olist>
    </inform-div1>
  </back>
</spec>
